{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../projects/forms/src/lib/form-builder.ts","../../../projects/forms/src/lib/input-file.directive.ts","../../../projects/forms/src/lib/ng-stack-forms.module.ts","../../../projects/forms/src/lib/form-array.ts","../../../projects/forms/src/lib/form-control.ts","../../../projects/forms/src/lib/form-group.ts","../../../projects/forms/src/lib/validators.ts","../../../projects/forms/src/lib/types.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","__values","o","s","Symbol","iterator","m","i","length","next","value","done","TypeError","FormBuilder","_super","group","controlsConfig","options","control","formState","validatorOrOpts","asyncValidator","array","NativeFormBuilder","Injectable","InputFileDirective","elementRef","renderer","select","EventEmitter","onChange","onTouched","defineProperty","undefined","_multiple","callOnChange","event","files","from","nativeElement","formData","FormData","formInputName","name","multiple","forEach","file","append","preserveValue","target","writeValue","fileList","FileList","setProperty","registerOnChange","fn","registerOnTouched","Directive","args","selector","providers","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","multi","ElementRef","Renderer2","HostBinding","type","Input","Output","HostListener","NgModule","declarations","exports","ReactiveFormsModule","FormArray","controls","_this","at","index","push","insert","setControl","setValue","patchValue","reset","getRawValue","setValidators","newValidator","setAsyncValidators","setErrors","errors","opts","getError","errorCode","controlName","hasError","NativeFormArray","FormControl","get","NativeFormControl","FormGroup","registerControl","addControl","removeControl","contains","NativeFormGroup","Validators","min","max","required","requiredTrue","email","minLength","maxLength","pattern","nullValidator","compose","validators","composeAsync","fileRequired","formControl","files_1","files_1_1","File","filesMinLength","requiredLength","actualLength","len","filesMaxLength","fileMaxSize","maxSize","files_2","files_2_1","size","requiredSize","actualSize","NativeValidators"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Injectable } from '@angular/core';\nimport { FormBuilder as NativeFormBuilder } from '@angular/forms';\n\nimport {\n  FbControlConfig,\n  LegacyControlOptions,\n  AbstractControlOptions,\n  ValidatorFn,\n  AsyncValidatorFn,\n  ValidatorsModel,\n  FormControlState,\n} from './types';\nimport { FormGroup } from './form-group';\nimport { FormControl } from './form-control';\nimport { FormArray } from './form-array';\n\n@Injectable()\nexport class FormBuilder extends NativeFormBuilder {\n  /**\n   * Construct a new `FormGroup` instance.\n   *\n   * @param controlsConfig A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param options Configuration options object for the `FormGroup`. The object can\n   * have two shapes:\n   *\n   * 1) `AbstractControlOptions` object (preferred), which consists of:\n   * - `validators`: A synchronous validator function, or an array of validator functions\n   * - `asyncValidators`: A single async validator or array of async validator functions\n   * - `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur' |\n   * submit')\n   *\n   * 2) Legacy configuration object, which consists of:\n   * - `validator`: A synchronous validator function, or an array of validator functions\n   * - `asyncValidator`: A single async validator or array of async validator functions\n   */\n  group<T extends object = any, V extends object = ValidatorsModel>(\n    controlsConfig: { [P in keyof T]: FbControlConfig<T[P], V> },\n    options: AbstractControlOptions | LegacyControlOptions | null = null\n  ): FormGroup<T, V> {\n    return super.group(controlsConfig, options) as FormGroup<T, V>;\n  }\n\n  /**\n   * @description\n   * Construct a new `FormControl` with the given state, validators and options.\n   *\n   * @param formState Initializes the control with an initial state value, or\n   * with an object that contains both a value and a disabled status.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains\n   * validation functions and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator\n   * functions.\n   *\n   * ### Initialize a control as disabled\n   *\n   * The following example returns a control with an initial value in a disabled state.\n```ts\nimport {Component, Inject} from '@angular/core';\nimport {FormBuilder, FormControl, FormGroup, Validators} from '@angular/forms';\n// ...\n@Component({\n  selector: 'app-disabled-form-control',\n  template: `\n    <input [formControl]=\"control\" placeholder=\"First\">\n  `\n})\nexport class DisabledFormControlComponent {\n  control: FormControl;\n\n  constructor(private fb: FormBuilder) {\n    this.control = fb.control({value: 'my val', disabled: true});\n  }\n}\n```\n   */\n  control<T = any, V extends object = ValidatorsModel>(\n    formState: FormControlState<T> = null,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ): FormControl<T, V> {\n    return super.control(formState, validatorOrOpts, asyncValidator) as FormControl<T, V>;\n  }\n\n  /**\n   * Constructs a new `FormArray` from the given array of configurations,\n   * validators and options.\n   *\n   * @param controlsConfig An array of child controls or control configs. Each\n   * child control is given an index when it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains\n   * validation functions and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator\n   * functions.\n   */\n  array<Item = any, V extends object = ValidatorsModel>(\n    controlsConfig: FbControlConfig<Item, V>[],\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ): FormArray<Item, V> {\n    return super.array(controlsConfig, validatorOrOpts, asyncValidator) as FormArray<Item, V>;\n  }\n}\n","import {\n  Directive,\n  ElementRef,\n  Renderer2,\n  HostListener,\n  forwardRef,\n  Input,\n  Output,\n  EventEmitter,\n  HostBinding,\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\n@Directive({\n  selector: `\n  input[type=file][ngModel],\n  input[type=file][formControl],\n  input[type=file][formControlName]`,\n  providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => InputFileDirective), multi: true }],\n})\nexport class InputFileDirective implements ControlValueAccessor {\n  private _multiple: boolean | string;\n  @HostBinding('attr.multiple') @Input() get multiple(): boolean | string {\n    return this._multiple !== undefined && this._multiple !== false && this._multiple !== 'false' ? '' : undefined;\n  }\n  set multiple(value: boolean | string) {\n    this._multiple = value;\n  }\n  @HostBinding('attr.preserveValue') @Input() preserveValue: boolean | string;\n  @Output() select = new EventEmitter<File[]>();\n  private onChange = (value: FormData) => {};\n  private onTouched = () => {};\n\n  constructor(private elementRef: ElementRef, private renderer: Renderer2) {}\n\n  /**\n   * Callback function that should be called when\n   * the control's value changes in the UI.\n   */\n  @HostListener('change', ['$event'])\n  callOnChange(event: any) {\n    this.onTouched();\n    const files = Array.from<File>(this.elementRef.nativeElement.files);\n    const formData = new FormData();\n\n    let formInputName = this.elementRef.nativeElement.name || 'uploadFile';\n    if (this.multiple !== undefined && this.multiple !== false && this.multiple !== 'false') {\n      formInputName += '[]';\n    }\n    files.forEach((file) => formData.append(formInputName, file));\n\n    this.onChange(formData);\n    this.select.next(files);\n    if (this.preserveValue === undefined || this.preserveValue === false || this.preserveValue === 'false') {\n      event.target.value = null;\n    }\n  }\n\n  /**\n   * Writes a new value to the element.\n   * This method will be called by the forms API to write\n   * to the view when programmatic (model -> view) changes are requested.\n   *\n   * See: [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor#members)\n   */\n  writeValue(fileList: FileList): void {\n    if (fileList && !(fileList instanceof FileList)) {\n      throw new TypeError('Value for input[type=file] must be an instance of FileList');\n    }\n    this.renderer.setProperty(this.elementRef.nativeElement, 'files', fileList);\n  }\n\n  /**\n   * Registers a callback function that should be called when\n   * the control's value changes in the UI.\n   *\n   * This is called by the forms API on initialization so it can update\n   * the form model when values propagate from the view (view -> model).\n   */\n  registerOnChange(fn: () => void): void {\n    this.onChange = fn;\n  }\n\n  /**\n   * Registers a callback function that should be called when the control receives a change event.\n   * This is called by the forms API on initialization so it can update the form model on change.\n   */\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { ReactiveFormsModule } from '@angular/forms';\n\nimport { FormBuilder } from './form-builder';\nimport { InputFileDirective } from './input-file.directive';\n\n@NgModule({\n  declarations: [InputFileDirective],\n  exports: [ReactiveFormsModule, InputFileDirective],\n  providers: [FormBuilder],\n})\nexport class NgStackFormsModule {}\n","import { FormArray as NativeFormArray } from '@angular/forms';\n\nimport { Observable } from 'rxjs';\n\nimport {\n  ControlType,\n  Status,\n  ValidatorFn,\n  AsyncValidatorFn,\n  ValidatorsModel,\n  ValidationErrors,\n  AbstractControlOptions,\n  StringKeys,\n  ExtractModelValue,\n  FormControlState,\n} from './types';\n\nexport class FormArray<Item = any, V extends object = ValidatorsModel> extends NativeFormArray {\n  readonly value: ExtractModelValue<Item>[];\n  readonly valueChanges: Observable<ExtractModelValue<Item>[]>;\n  readonly status: Status;\n  readonly statusChanges: Observable<Status>;\n  readonly errors: ValidationErrors<V> | null;\n\n  /**\n   * Creates a new `FormArray` instance.\n   *\n   * @param controls An array of child controls. Each child control is given an index\n   * where it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(\n    public controls: ControlType<Item, V>[],\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ) {\n    super(controls, validatorOrOpts, asyncValidator);\n  }\n\n  /**\n   * Get the Control at the given `index` in the array.\n   *\n   * @param index Index in the array to retrieve the control\n   */\n  at(index: number) {\n    return super.at(index) as ControlType<Item, V>;\n  }\n\n  /**\n   * Insert a new Control at the end of the array.\n   *\n   * @param control Form control to be inserted\n   */\n  push(control: ControlType<Item, V>) {\n    return super.push(control);\n  }\n\n  /**\n   * Insert a new Control at the given `index` in the array.\n   *\n   * @param index Index in the array to insert the control\n   * @param control Form control to be inserted\n   */\n  insert(index: number, control: ControlType<Item, V>) {\n    return super.insert(index, control);\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param index Index in the array to replace the control\n   * @param control The Control control to replace the existing control\n   */\n  setControl(index: number, control: ControlType<Item, V>) {\n    return super.setControl(index, control);\n  }\n\n  /**\n   * Sets the value of the `FormArray`. It accepts an array that matches\n   * the structure of the control.\n   *\n   * This method performs strict checks, and throws an error if you try\n   * to set the value of a control that doesn't exist or if you exclude the\n   * value of a control.\n   *\n   * ### Set the values for the controls in the form array\n   *\n```ts\nconst arr = new FormArray([\n  new FormControl(),\n  new FormControl()\n]);\nconsole.log(arr.value);   // [null, null]\n\narr.setValue(['Nancy', 'Drew']);\nconsole.log(arr.value);   // ['Nancy', 'Drew']\n```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   */\n  setValue(value: ExtractModelValue<Item>[], options: { onlySelf?: boolean; emitEvent?: boolean } = {}) {\n    return super.setValue(value, options);\n  }\n\n  /**\n   * Patches the value of the `FormArray`. It accepts an array that matches the\n   * structure of the control, and does its best to match the values to the correct\n   * controls in the group.\n   *\n   * It accepts both super-sets and sub-sets of the array without throwing an error.\n   *\n   * ### Patch the values for controls in a form array\n   *\n```ts\nconst arr = new FormArray([\n   new FormControl(),\n   new FormControl()\n]);\nconsole.log(arr.value);   // [null, null]\n\narr.patchValue(['Nancy']);\nconsole.log(arr.value);   // ['Nancy', null]\n```\n   *\n   * @param value Array of latest values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   */\n  patchValue(value: ExtractModelValue<Item>[], options: { onlySelf?: boolean; emitEvent?: boolean } = {}) {\n    return super.patchValue(value, options);\n  }\n\n  /**\n   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n   * value of all descendants to null or null maps.\n   *\n   * You reset to a specific form state by passing in an array of states\n   * that matches the structure of the control. The state is a standalone value\n   * or a form state object with both a value and a disabled status.\n   *\n   * ### Reset the values in a form array\n   *\n```ts\nconst arr = new FormArray([\n   new FormControl(),\n   new FormControl()\n]);\narr.reset(['name', 'last name']);\n\nconsole.log(this.arr.value);  // ['name', 'last name']\n```\n   *\n   * ### Reset the values in a form array and the disabled status for the first control\n   *\n```\nthis.arr.reset([\n  {value: 'name', disabled: true},\n  'last'\n]);\n\nconsole.log(this.arr.value);  // ['name', 'last name']\nconsole.log(this.arr.get(0).status);  // 'DISABLED'\n```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   */\n  reset(value: FormControlState<Item>[] = [], options: { onlySelf?: boolean; emitEvent?: boolean } = {}) {\n    return super.reset(value, options);\n  }\n\n  /**\n   * The aggregate value of the array, including any disabled controls.\n   *\n   * Reports all values regardless of disabled status.\n   * For enabled controls only, the `value` property is the best way to get the value of the array.\n   */\n  getRawValue() {\n    return super.getRawValue() as ExtractModelValue<Item>[];\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control. Calling\n   * this overwrites any existing sync validators.\n   */\n  setValidators(newValidator: ValidatorFn | ValidatorFn[] | null) {\n    return super.setValidators(newValidator);\n  }\n\n  /**\n   * Sets the async validators that are active on this control. Calling this\n   * overwrites any existing async validators.\n   */\n  setAsyncValidators(newValidator: AsyncValidatorFn | AsyncValidatorFn[] | null) {\n    return super.setAsyncValidators(newValidator);\n  }\n\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * ### Manually set the errors for a control\n   *\n   * ```ts\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n  setErrors(errors: ValidationErrors | null, opts: { emitEvent?: boolean } = {}) {\n    return super.setErrors(errors, opts);\n  }\n\n  /**\n   * Reports error data for the control with the given controlName.\n   *\n   * @param errorCode The code of the error to check\n   * @param controlName A control name that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * For example, for the following `FormGroup`:\n   *\n```ts\nform = new FormGroup({\n  address: new FormGroup({ street: new FormControl() })\n});\n```\n   *\n   * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in combination with `get()` method:\n   * \n```ts\nform.get('address').getError('someErrorCode', 'street');\n```\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n  getError<P extends StringKeys<V>, K extends StringKeys<Item>>(errorCode: P, controlName?: K) {\n    return super.getError(errorCode, controlName) as V[P] | null;\n  }\n\n  /**\n   * Reports whether the control with the given controlName has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param controlName A control name that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * For example, for the following `FormGroup`:\n   *\n```ts\nform = new FormGroup({\n  address: new FormGroup({ street: new FormControl() })\n});\n```\n   *\n   * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in combination with `get()` method:\n```ts\nform.get('address').hasError('someErrorCode', 'street');\n```\n   *\n   * If no controlName is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given controlName.\n   *\n   * If the control is not present, false is returned.\n   */\n  hasError<P extends StringKeys<V>, K extends StringKeys<Item>>(errorCode: P, controlName?: K) {\n    return super.hasError(errorCode, controlName);\n  }\n}\n","import { FormControl as NativeFormControl } from '@angular/forms';\n\nimport { Observable } from 'rxjs';\n\nimport {\n  Status,\n  ValidationErrors,\n  StringKeys,\n  ValidatorFn,\n  AsyncValidatorFn,\n  AbstractControlOptions,\n  ValidatorsModel,\n  ExtractControlValue,\n  FormControlState,\n} from './types';\n\nexport class FormControl<T = any, V extends object = ValidatorsModel> extends NativeFormControl {\n  readonly value: ExtractControlValue<T>;\n  readonly valueChanges: Observable<ExtractControlValue<T>>;\n  readonly status: Status;\n  readonly statusChanges: Observable<Status>;\n  readonly errors: ValidationErrors<V> | null;\n\n  /**\n   * Creates a new `FormControl` instance.\n   *\n   * @param formState Initializes the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(\n    formState: FormControlState<T> = null,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ) {\n    super(formState, validatorOrOpts, asyncValidator);\n  }\n\n  /**\n   * Sets a new value for the form control.\n   *\n   * @param value The new value for the control.\n   * @param options Configuration options that determine how the control proopagates changes\n   * and emits events when the value changes.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\n   * `onChange` event to\n   * update the view.\n   * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\n   * `ngModelChange`\n   * event to update the model.\n   *\n   */\n  setValue(\n    value: ExtractControlValue<T>,\n    options: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n      emitModelToViewChange?: boolean;\n      emitViewToModelChange?: boolean;\n    } = {}\n  ) {\n    return super.setValue(value, options);\n  }\n\n  /**\n   * Patches the value of a control.\n   *\n   * This function is functionally the same as [setValue](https://angular.io/api/forms/FormControl#setValue) at this level.\n   * It exists for symmetry with [patchValue](https://angular.io/api/forms/FormGroup#patchValue) on `FormGroups` and\n   * `FormArrays`, where it does behave differently.\n   *\n   * See also: `setValue` for options\n   */\n  patchValue(\n    value: ExtractControlValue<T>,\n    options: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n      emitModelToViewChange?: boolean;\n      emitViewToModelChange?: boolean;\n    } = {}\n  ) {\n    return super.patchValue(value, options);\n  }\n\n  /**\n   * Resets the form control, marking it `pristine` and `untouched`, and setting\n   * the value to null.\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   *\n   */\n  reset(\n    formState: FormControlState<T> = null,\n    options: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n    } = {}\n  ) {\n    return super.reset(formState, options);\n  }\n\n  /**\n   * In `FormControl`, this method always returns `null`.\n   */\n  get(): null {\n    return null;\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control. Calling\n   * this overwrites any existing sync validators.\n   */\n  setValidators(newValidator: ValidatorFn | ValidatorFn[] | null) {\n    return super.setValidators(newValidator);\n  }\n\n  /**\n   * Sets the async validators that are active on this control. Calling this\n   * overwrites any existing async validators.\n   */\n  setAsyncValidators(newValidator: AsyncValidatorFn | AsyncValidatorFn[] | null) {\n    return super.setAsyncValidators(newValidator);\n  }\n\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * ### Manually set the errors for a control\n   *\n   * ```ts\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n  setErrors(errors: ValidationErrors | null, opts: { emitEvent?: boolean } = {}) {\n    return super.setErrors(errors, opts);\n  }\n\n  /**\n   * Reports error data for the current control.\n   *\n   * @param errorCode The code of the error to check.\n   *\n   * @returns error data for that particular error. If an error is not present,\n   * null is returned.\n   */\n  getError<K extends StringKeys<V> = any>(errorCode: K) {\n    return super.getError(errorCode) as V[K] | null;\n  }\n\n  /**\n   * Reports whether the current control has the error specified.\n   *\n   * @param errorCode The code of the error to check.\n   *\n   * @returns whether the given error is present in the current control.\n   *\n   * If an error is not present, false is returned.\n   */\n  hasError<K extends StringKeys<V> = any>(errorCode: K) {\n    return super.hasError(errorCode);\n  }\n}\n","import { FormGroup as NativeFormGroup } from '@angular/forms';\n\nimport { Observable } from 'rxjs';\n\nimport {\n  Status,\n  StringKeys,\n  ValidatorFn,\n  AsyncValidatorFn,\n  ValidatorsModel,\n  ValidationErrors,\n  AbstractControlOptions,\n  ControlType,\n  ExtractGroupValue,\n} from './types';\n\nexport class FormGroup<T extends object = any, V extends object = ValidatorsModel> extends NativeFormGroup {\n  readonly value: ExtractGroupValue<T>;\n  readonly valueChanges: Observable<ExtractGroupValue<T>>;\n  readonly status: Status;\n  readonly statusChanges: Observable<Status>;\n  readonly errors: ValidationErrors<V> | null;\n\n  /**\n   * Creates a new `FormGroup` instance.\n   *\n   * @param controls A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   * @todo Chechout how to respect optional and require properties modifyers for the controls.\n   */\n  constructor(\n    public controls: { [P in keyof T]: ControlType<T[P], V> },\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ) {\n    super(controls, validatorOrOpts, asyncValidator);\n  }\n\n  /**\n   * Registers a control with the group's list of controls.\n   *\n   * This method does not update the value or validity of the control.\n   * Use [addControl](https://angular.io/api/forms/FormGroup#addControl) instead.\n   *\n   * @param name The control name to register in the collection\n   * @param control Provides the control for the given name\n   */\n  registerControl<K extends StringKeys<T>, CV extends object = ValidatorsModel>(\n    name: K,\n    control: ControlType<T[K], CV>\n  ) {\n    return super.registerControl(name, control) as ControlType<T[K], CV>;\n  }\n\n  /**\n   * Add a control to this group.\n   *\n   * This method also updates the value and validity of the control.\n   *\n   * @param name The control name to add to the collection\n   * @param control Provides the control for the given name\n   */\n  addControl<K extends StringKeys<T>, CV extends object = ValidatorsModel>(name: K, control: ControlType<T[K], CV>) {\n    return super.addControl(name, control);\n  }\n\n  /**\n   * Remove a control from this group.\n   *\n   * @param name The control name to remove from the collection\n   */\n  removeControl<K extends StringKeys<T>>(name: K) {\n    return super.removeControl(name);\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param name The control name to replace in the collection\n   * @param control Provides the control for the given name\n   */\n  setControl<K extends StringKeys<T>, CV extends object = ValidatorsModel>(name: K, control: ControlType<T[K], CV>) {\n    return super.setControl(name, control);\n  }\n\n  /**\n   * Check whether there is an enabled control with the given name in the group.\n   *\n   * Reports false for disabled controls. If you'd like to check for existence in the group\n   * only, use [get](https://angular.io/api/forms/AbstractControl#get) instead.\n   *\n   * @param name The control name to check for existence in the collection\n   *\n   * @returns false for disabled controls, true otherwise.\n   */\n  contains<K extends StringKeys<T>>(name: K) {\n    return super.contains(name);\n  }\n\n  /**\n   * Sets the value of the `FormGroup`. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * ### Set the complete value for the form group\n   *\n```ts\nconst form = new FormGroup({\n  first: new FormControl(),\n  last: new FormControl()\n});\n\nconsole.log(form.value);   // {first: null, last: null}\n\nform.setValue({first: 'Nancy', last: 'Drew'});\nconsole.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n```\n   *\n   * @throws When strict checks fail, such as setting the value of a control\n   * that doesn't exist or if you excluding the value of a control.\n   *\n   * @param value The new value for the control that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   */\n  setValue(value: ExtractGroupValue<T>, options: { onlySelf?: boolean; emitEvent?: boolean } = {}) {\n    return super.setValue(value, options);\n  }\n\n  /**\n   * Patches the value of the `FormGroup`. It accepts an object with control\n   * names as keys, and does its best to match the values to the correct controls\n   * in the group.\n   *\n   * It accepts both super-sets and sub-sets of the group without throwing an error.\n   *\n   * ### Patch the value for a form group\n   *\n```ts\nconst form = new FormGroup({\n   first: new FormControl(),\n   last: new FormControl()\n});\nconsole.log(form.value);   // {first: null, last: null}\n\nform.patchValue({first: 'Nancy'});\nconsole.log(form.value);   // {first: 'Nancy', last: null}\n```\n   *\n   * @param value The object that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes and\n   * emits events after the value is patched.\n   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n   * true.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   */\n  patchValue(value: Partial<ExtractGroupValue<T>>, options: { onlySelf?: boolean; emitEvent?: boolean } = {}) {\n    return super.patchValue(value, options);\n  }\n\n  /**\n   * Resets the `FormGroup`, marks all descendants are marked `pristine` and `untouched`, and\n   * the value of all descendants to null.\n   *\n   * You reset to a specific form state by passing in a map of states\n   * that matches the structure of your form, with control names as keys. The state\n   * is a standalone value or a form state object with both a value and a disabled\n   * status.\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the group is reset.\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   *\n   *\n   * ### Reset the form group values\n   *\n```ts\nconst form = new FormGroup({\n  first: new FormControl('first name'),\n  last: new FormControl('last name')\n});\n\nconsole.log(form.value);  // {first: 'first name', last: 'last name'}\n\nform.reset({ first: 'name', last: 'last name' });\n\nconsole.log(form.value);  // {first: 'name', last: 'last name'}\n```\n   *\n   * ### Reset the form group values and disabled status\n   *\n```ts\nconst form = new FormGroup({\n  first: new FormControl('first name'),\n  last: new FormControl('last name')\n});\n\nform.reset({\n  first: {value: 'name', disabled: true},\n  last: 'last'\n});\n\nconsole.log(this.form.value);  // {first: 'name', last: 'last name'}\nconsole.log(this.form.get('first').status);  // 'DISABLED'\n```\n   */\n  reset(value: ExtractGroupValue<T> = {} as any, options: { onlySelf?: boolean; emitEvent?: boolean } = {}) {\n    return super.reset(value, options);\n  }\n\n  /**\n   * The aggregate value of the `FormGroup`, including any disabled controls.\n   *\n   * Retrieves all values regardless of disabled status.\n   * The `value` property is the best way to get the value of the group, because\n   * it excludes disabled controls in the `FormGroup`.\n   */\n  getRawValue() {\n    return super.getRawValue() as ExtractGroupValue<T>;\n  }\n\n  /**\n   * Retrieves a child control given the control's name.\n   *\n   * ### Retrieve a nested control\n   *\n   * For example, to get a `name` control nested within a `person` sub-group:\n```ts\nthis.form.get('person').get('name');\n```\n   */\n  get<K extends StringKeys<T>, CV extends object = ValidatorsModel>(controlName: K): ControlType<T[K], CV> | null {\n    return super.get(controlName) as ControlType<T[K], CV> | null;\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control. Calling\n   * this overwrites any existing sync validators.\n   */\n  setValidators(newValidator: ValidatorFn | ValidatorFn[] | null) {\n    return super.setValidators(newValidator);\n  }\n\n  /**\n   * Sets the async validators that are active on this control. Calling this\n   * overwrites any existing async validators.\n   */\n  setAsyncValidators(newValidator: AsyncValidatorFn | AsyncValidatorFn[] | null) {\n    return super.setAsyncValidators(newValidator);\n  }\n\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * ### Manually set the errors for a control\n   *\n   * ```ts\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n  setErrors(errors: ValidationErrors | null, opts: { emitEvent?: boolean } = {}) {\n    return super.setErrors(errors, opts);\n  }\n\n  /**\n   * Reports error data for the control with the given controlName.\n   *\n   * @param errorCode The code of the error to check\n   * @param controlName A control name that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * For example, for the following `FormGroup`:\n   *\n```ts\nform = new FormGroup({\n  address: new FormGroup({ street: new FormControl() })\n});\n```\n   *\n   * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in combination with `get()` method:\n   * \n```ts\nform.get('address').getError('someErrorCode', 'street');\n```\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n  getError<P extends StringKeys<V>, K extends StringKeys<T>>(errorCode: P, controlName?: K) {\n    return super.getError(errorCode, controlName) as V[P] | null;\n  }\n\n  /**\n   * Reports whether the control with the given controlName has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param controlName A control name that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * For example, for the following `FormGroup`:\n   *\n```ts\nform = new FormGroup({\n  address: new FormGroup({ street: new FormControl() })\n});\n```\n   *\n   * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in combination with `get()` method:\n```ts\nform.get('address').hasError('someErrorCode', 'street');\n```\n   *\n   * If no controlName is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given controlName.\n   *\n   * If the control is not present, false is returned.\n   */\n  hasError<P extends StringKeys<V>, K extends StringKeys<T>>(errorCode: P, controlName?: K) {\n    return super.hasError(errorCode, controlName);\n  }\n}\n","import { Validators as NativeValidators, AbstractControl } from '@angular/forms';\n\nimport { ValidatorFn, ValidationErrors, AsyncValidatorFn } from './types';\nimport { FormControl } from './form-control';\n\n// Next flag used because of this https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-373487183\n// @dynamic\n/**\n * Provides a set of built-in validators that can be used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns an error map or null. A null map means that validation has passed.\n *\n * See also [Form Validation](https://angular.io/guide/form-validation).\n */\nexport class Validators extends NativeValidators {\n  /**\n   * Validator that requires the control's value to be greater than or equal to the provided number.\n   * The validator exists only as a function and not as a directive.\n   *\n   * ### Validate against a minimum of 3\n   *\n   * ```ts\n   * const control = new FormControl(2, Validators.min(3));\n   *\n   * console.log(control.errors); // {min: {min: 3, actual: 2}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `min` property if the validation check fails, otherwise `null`.\n   *\n   */\n  static min(min: number) {\n    return super.min(min) as ValidatorFn<{ min: { min: number; actual: number } }>;\n  }\n\n  /**\n   * Validator that requires the control's value to be less than or equal to the provided number.\n   * The validator exists only as a function and not as a directive.\n   *\n   * ### Validate against a maximum of 15\n   *\n   * ```ts\n   * const control = new FormControl(16, Validators.max(15));\n   *\n   * console.log(control.errors); // {max: {max: 15, actual: 16}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `max` property if the validation check fails, otherwise `null`.\n   *\n   */\n  static max(max: number) {\n    return super.max(max) as ValidatorFn<{ max: { max: number; actual: number } }>;\n  }\n\n  /**\n   * Validator that requires the control have a non-empty value.\n   *\n   * ### Validate that the field is non-empty\n   *\n   * ```ts\n   * const control = new FormControl('', Validators.required);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map with the `required` property\n   * if the validation check fails, otherwise `null`.\n   *\n   */\n  static required(control: AbstractControl) {\n    return super.required(control) as ValidationErrors<{ required: true }> | null;\n  }\n\n  /**\n   * Validator that requires the control's value be true. This validator is commonly\n   * used for required checkboxes.\n   *\n   * ### Validate that the field value is true\n   *\n   * ```typescript\n   * const control = new FormControl('', Validators.requiredTrue);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map that contains the `required` property\n   * set to `true` if the validation check fails, otherwise `null`.\n   */\n  static requiredTrue(control: AbstractControl) {\n    return super.requiredTrue(control) as ValidationErrors<{ required: true }> | null;\n  }\n\n  /**\n   * Validator that requires the control's value pass an email validation test.\n   *\n   * ### Validate that the field matches a valid email pattern\n   *\n   * ```typescript\n   * const control = new FormControl('bad@', Validators.email);\n   *\n   * console.log(control.errors); // {email: true}\n   * ```\n   *\n   * @returns An error map with the `email` property\n   * if the validation check fails, otherwise `null`.\n   *\n   */\n  static email(control: AbstractControl) {\n    return super.email(control) as ValidationErrors<{ email: true }> | null;\n  }\n\n  /**\n   * Validator that requires the length of the control's value to be greater than or equal\n   * to the provided minimum length. This validator is also provided by default if you use the\n   * the HTML5 `minlength` attribute.\n   *\n   * ### Validate that the field has a minimum of 3 characters\n   *\n   * ```typescript\n   * const control = new FormControl('ng', Validators.minLength(3));\n   *\n   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n   * ```\n   *\n   * ```html\n   * <input minlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `minlength` if the validation check fails, otherwise `null`.\n   */\n  static minLength(minLength: number) {\n    return super.minLength(minLength) as ValidatorFn<{\n      minlength: { requiredLength: number; actualLength: number };\n    }>;\n  }\n\n  /**\n   * Validator that requires the length of the control's value to be less than or equal\n   * to the provided maximum length. This validator is also provided by default if you use the\n   * the HTML5 `maxlength` attribute.\n   *\n   * ### Validate that the field has maximum of 5 characters\n   *\n   * ```typescript\n   * const control = new FormControl('Angular', Validators.maxLength(5));\n   *\n   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n   * ```\n   *\n   * ```html\n   * <input maxlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `maxlength` property if the validation check fails, otherwise `null`.\n   */\n  static maxLength(maxLength: number) {\n    return super.maxLength(maxLength) as ValidatorFn<{\n      maxlength: { requiredLength: number; actualLength: number };\n    }>;\n  }\n\n  /**\n   * Validator that requires the control's value to match a regex pattern. This validator is also\n   * provided by default if you use the HTML5 `pattern` attribute.\n   *\n   * Note that if a Regexp is provided, the Regexp is used as is to test the values. On the other\n   * hand, if a string is passed, the `^` character is prepended and the `$` character is\n   * appended to the provided string (if not already present), and the resulting regular\n   * expression is used to test the values.\n   *\n   * ### Validate that the field only contains letters or spaces\n   *\n   * ```typescript\n   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n   *\n   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n   * ```\n   *\n   * ```html\n   * <input pattern=\"[a-zA-Z ]*\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `pattern` property if the validation check fails, otherwise `null`.\n   */\n  static pattern(pattern: string | RegExp) {\n    return super.pattern(pattern) as ValidatorFn<{\n      pattern: { requiredPattern: string; actualValue: string };\n    }>;\n  }\n\n  /**\n   * Validator that performs no operation.\n   */\n  static nullValidator(control: AbstractControl): null {\n    return null;\n  }\n\n  /**\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error maps of the validators if the validation check fails, otherwise `null`.\n   */\n  static compose(validators: null): null;\n  static compose<T extends object = any>(validators: (ValidatorFn | null | undefined)[]): ValidatorFn<T> | null;\n  static compose<T extends object = any>(validators: (ValidatorFn | null | undefined)[] | null): ValidatorFn<T> | null {\n    return super.compose(validators) as ValidatorFn<T> | null;\n  }\n\n  /**\n   * Compose multiple async validators into a single function that returns the union\n   * of the individual error objects for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error objects of the async validators if the validation check fails, otherwise `null`.\n   */\n  static composeAsync<T extends object = any>(validators: (AsyncValidatorFn<T> | null)[]) {\n    return super.composeAsync(validators) as AsyncValidatorFn<T> | null;\n  }\n\n  /**\n   * At least one file should be.\n   *\n   * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n   */\n  static fileRequired(formControl: FormControl<FormData>): ValidationErrors<{ fileRequired: true }> | null {\n    if (!(formControl.value instanceof FormData)) {\n      return { fileRequired: true };\n    }\n\n    const files: File[] = [];\n    formControl.value.forEach((file: File) => files.push(file));\n\n    for (const file of files) {\n      if (file instanceof File) {\n        return null;\n      }\n    }\n\n    return { fileRequired: true };\n  }\n\n  /**\n   * Minimal number of files.\n   *\n   * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n   */\n  static filesMinLength(\n    minLength: number\n  ): ValidatorFn<{\n    filesMinLength: { requiredLength: number; actualLength: number };\n  }> {\n    return (formControl: FormControl<FormData>) => {\n      const value = formControl.value;\n\n      if (minLength < 1) {\n        return null;\n      }\n\n      if (!value || !(value instanceof FormData)) {\n        return { filesMinLength: { requiredLength: minLength, actualLength: 0 } };\n      }\n\n      const files: File[] = [];\n      value.forEach((file: File) => files.push(file));\n      const len = files.length;\n      if (len < minLength) {\n        return { filesMinLength: { requiredLength: minLength, actualLength: len } };\n      }\n\n      return null;\n    };\n  }\n\n  /**\n   * Maximal number of files.\n   *\n   * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n   */\n  static filesMaxLength(\n    maxLength: number\n  ): ValidatorFn<{\n    filesMaxLength: { requiredLength: number; actualLength: number };\n  }> {\n    return (formControl: FormControl<FormData>) => {\n      if (!(formControl.value instanceof FormData)) {\n        return null;\n      }\n\n      const files: File[] = [];\n      formControl.value.forEach((file: File) => files.push(file));\n      const len = files.length;\n      if (len > maxLength) {\n        return { filesMaxLength: { requiredLength: maxLength, actualLength: len } };\n      }\n\n      return null;\n    };\n  }\n\n  /**\n   * Maximal size of a file.\n   *\n   * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n   */\n  static fileMaxSize(\n    maxSize: number\n  ): ValidatorFn<{\n    fileMaxSize: { requiredSize: number; actualSize: number; file: File };\n  }> {\n    return (formControl: FormControl<FormData>) => {\n      if (!(formControl.value instanceof FormData)) {\n        return null;\n      }\n\n      const files: File[] = [];\n      formControl.value.forEach((file: File) => files.push(file));\n      for (const file of files) {\n        if (file instanceof File && file.size > maxSize) {\n          return { fileMaxSize: { requiredSize: maxSize, actualSize: file.size, file } };\n        }\n      }\n\n      return null;\n    };\n  }\n}\n","import { AbstractControl } from '@angular/forms';\n\nimport { Observable } from 'rxjs';\n\nimport { FormArray } from './form-array';\nimport { FormGroup } from './form-group';\nimport { FormControl } from './form-control';\n\n/**\n * This type marks a property of a form model as property\n * which is intended for an instance of `FormControl`.\n *\n * If a property of your form model have a primitive type,\n * in appropriate form field the instance of `FormControl` will be automatically assigned.\n * But if the property have a type that extends `object` - you need `Control<T>`.\n *\n * ### Example:\n```ts\nimport { FormBuilder, Control } from '@ng-stack/forms';\n\nconst fb = new FormBuilder();\n\n// Form Model\ninterface Person {\n  id: number;\n  name: string;\n  birthDate: Control<Date>; // Here should be FormControl, instead of a FormGroup\n}\n\nconst form = fb.group<Person>({\n  id: 123,\n  name: 'John Smith',\n  birthDate: new Date(1977, 6, 30),\n});\n\nconst birthDate: Date = form.value.birthDate;\n```\n * ## External form model\n * \n * If the form model interface comes from an external library, you can do the following:\n *\n```ts\nimport { FormBuilder, Control } from '@ng-stack/forms';\n\nconst fb = new FormBuilder();\n\n// External Form Model\ninterface ExternalPerson {\n  id: number;\n  name: string;\n  birthDate: Date;\n}\n\nconst configForm: ExternalPerson = {\n  id: 123,\n  name: 'John Smith',\n  birthDate: new Date(1977, 6, 30),\n};\n\ninterface Person extends ExternalPerson {\n  birthDate: Control<Date>;\n}\n\nconst form = fb.group<Person>(configForm); // `Control<Date>` type is compatible with `Date` type.\n\nconst birthDate: Date = form.value.birthDate; // `Control<Date>` type is compatible with `Date` type.\n```\n */\nexport type Control<T extends object> = T & UniqToken;\n\nconst sym = Symbol();\n\ninterface UniqToken {\n  [sym]: never;\n}\n\n/**\n * Extract `keyof T` with string keys.\n */\nexport type StringKeys<T> = Extract<keyof T, string>;\n\ntype ExtractAny<T> = T extends Extract<T, string & number & boolean & object & null & undefined> ? any : never;\n\n/**\n * This type is a conditional type that automatically detects\n * appropriate types for form controls by given type for its generic.\n */\nexport type ControlType<T, V extends object = ValidatorsModel> = [T] extends [ExtractAny<T>]\n  ? FormGroup<any, V> | FormControl<any, V> | FormArray<any, V>\n  : [T] extends [Control<infer ControlModel>]\n  ? FormControl<ControlModel, V>\n  : [T] extends [Array<infer Item>]\n  ? FormArray<Item, V>\n  : [T] extends [object]\n  ? FormGroup<T, V>\n  : FormControl<T, V>;\n\nexport type FormControlState<T> =\n  | null\n  | ExtractModelValue<T>\n  | {\n      value: null | ExtractModelValue<T>;\n      disabled: boolean;\n    };\n\n/**\n * Clears the form model from `Control<T>` type.\n */\nexport type ExtractModelValue<T> = [T] extends [ExtractAny<T>]\n  ? any\n  : [T] extends [Array<infer Item>]\n  ? Array<ExtractModelValue<Item>>\n  : [T] extends [Control<infer ControlModel>]\n  ? ControlModel\n  : [T] extends [object]\n  ? ExtractGroupValue<T>\n  : T;\n\nexport type ExtractControlValue<T> = [T] extends [Control<infer ControlModel>] ? ControlModel : T;\n\n/**\n * Clears the form model (as object) from `Control<T>` type.\n */\nexport type ExtractGroupValue<T extends object> = {\n  [P in keyof T]: ExtractModelValue<T[P]>;\n};\n\nexport type ExtractGroupStateValue<T extends object> = {\n  [P in keyof T]: FormControlState<T[P]>;\n};\n\n/**\n * Form builder control config.\n */\nexport type FbControlConfig<T, V extends object = ValidatorsModel> = [T] extends [ExtractAny<T>]\n  ? FormGroup<any, V> | FbControl<any, V> | FormArray<any, V>\n  : [T] extends [Control<infer ControlModel>]\n  ? FbControl<ControlModel, V>\n  : [T] extends [Array<infer Item>]\n  ? FormArray<Item, V>\n  : [T] extends [object]\n  ? FormGroup<T, V>\n  : FbControl<T, V>;\n\n/**\n * Form builder control.\n */\nexport type FbControl<T, V extends object = ValidatorsModel> =\n  | ExtractModelValue<T>\n  | FormControlState<T>\n  | [\n      FormControlState<T>,\n      (ValidatorFn | ValidatorFn[] | AbstractControlOptions)?,\n      (AsyncValidatorFn | AsyncValidatorFn[])?\n    ]\n  | FormControl<T, V>;\n\n/**\n * The validation status of the control. There are four possible\n * validation status values:\n *\n * * **VALID**: This control has passed all validation checks.\n * * **INVALID**: This control has failed at least one validation check.\n * * **PENDING**: This control is in the midst of conducting a validation check.\n * * **DISABLED**: This control is exempt from validation checks.\n *\n * These status values are mutually exclusive, so a control cannot be\n * both valid AND invalid or invalid AND disabled.\n */\nexport type Status = 'VALID' | 'INVALID' | 'PENDING' | 'DISABLED';\n\n/**\n * Interface for options provided to an `AbstractControl`.\n */\nexport interface AbstractControlOptions<T extends object = any> {\n  /**\n   * The list of validators applied to a control.\n   */\n  validators?: ValidatorFn<T> | ValidatorFn<T>[] | null;\n  /**\n   * The list of async validators applied to control.\n   */\n  asyncValidators?: AsyncValidatorFn<T> | AsyncValidatorFn<T>[] | null;\n  /**\n   * The event name for control to update upon.\n   */\n  updateOn?: 'change' | 'blur' | 'submit';\n}\n\n/**\n * Form builder legacy control options.\n */\nexport interface LegacyControlOptions {\n  validator: ValidatorFn | ValidatorFn[] | null;\n  asyncValidator: AsyncValidatorFn | AsyncValidatorFn[] | null;\n}\n\n/**\n * A function that receives a control and synchronously returns a map of\n * validation errors if present, otherwise null.\n */\nexport type ValidatorFn<T extends object = any> = (control: AbstractControl) => ValidationErrors<T> | null;\n\n/**\n * A function that receives a control and returns a Promise or observable\n * that emits validation errors if present, otherwise null.\n */\nexport type AsyncValidatorFn<T extends object = any> = (\n  control: AbstractControl\n) => Promise<ValidationErrors<T> | null> | Observable<ValidationErrors<T> | null>;\n\n/**\n * Defines the map of errors returned from failed validation checks.\n */\nexport type ValidationErrors<T extends object = any> = T;\n\n/**\n * The default validators model, it includes almost all static properties of `Validators`,\n * excludes: `prototype`, `compose`, `composeAsync` and `nullValidator`.\n *\n * ### Usage\n *\n```ts\nconst formControl = new FormControl<string, ValidatorsModel>('some value');\n// OR\nconst formGroup = new FormGroup<any, ValidatorsModel>({});\n// OR\nconst formArray = new FormArray<any, ValidatorsModel>([]);\n```\n */\nexport class ValidatorsModel {\n  min: { min: number; actual: number };\n  max: { max: number; actual: number };\n  required: true;\n  email: true;\n  minlength: { requiredLength: number; actualLength: number };\n  maxlength: { requiredLength: number; actualLength: number };\n  pattern: { requiredPattern: string; actualValue: string };\n  fileRequired: { requiredSize: number; actualSize: number; file: File };\n  filesMinLength: { requiredLength: number; actualLength: number };\n  filesMaxLength: { requiredLength: number; actualLength: number };\n  fileMaxSize: { requiredSize: number; actualSize: number; file: File };\n}\n"]}