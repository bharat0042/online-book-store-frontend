import { Validators as NativeValidators } from '@angular/forms';
// Next flag used because of this https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-373487183
// @dynamic
/**
 * Provides a set of built-in validators that can be used by form controls.
 *
 * A validator is a function that processes a `FormControl` or collection of
 * controls and returns an error map or null. A null map means that validation has passed.
 *
 * See also [Form Validation](https://angular.io/guide/form-validation).
 */
export class Validators extends NativeValidators {
    /**
     * Validator that requires the control's value to be greater than or equal to the provided number.
     * The validator exists only as a function and not as a directive.
     *
     * ### Validate against a minimum of 3
     *
     * ```ts
     * const control = new FormControl(2, Validators.min(3));
     *
     * console.log(control.errors); // {min: {min: 3, actual: 2}}
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `min` property if the validation check fails, otherwise `null`.
     *
     */
    static min(min) {
        return super.min(min);
    }
    /**
     * Validator that requires the control's value to be less than or equal to the provided number.
     * The validator exists only as a function and not as a directive.
     *
     * ### Validate against a maximum of 15
     *
     * ```ts
     * const control = new FormControl(16, Validators.max(15));
     *
     * console.log(control.errors); // {max: {max: 15, actual: 16}}
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `max` property if the validation check fails, otherwise `null`.
     *
     */
    static max(max) {
        return super.max(max);
    }
    /**
     * Validator that requires the control have a non-empty value.
     *
     * ### Validate that the field is non-empty
     *
     * ```ts
     * const control = new FormControl('', Validators.required);
     *
     * console.log(control.errors); // {required: true}
     * ```
     *
     * @returns An error map with the `required` property
     * if the validation check fails, otherwise `null`.
     *
     */
    static required(control) {
        return super.required(control);
    }
    /**
     * Validator that requires the control's value be true. This validator is commonly
     * used for required checkboxes.
     *
     * ### Validate that the field value is true
     *
     * ```typescript
     * const control = new FormControl('', Validators.requiredTrue);
     *
     * console.log(control.errors); // {required: true}
     * ```
     *
     * @returns An error map that contains the `required` property
     * set to `true` if the validation check fails, otherwise `null`.
     */
    static requiredTrue(control) {
        return super.requiredTrue(control);
    }
    /**
     * Validator that requires the control's value pass an email validation test.
     *
     * ### Validate that the field matches a valid email pattern
     *
     * ```typescript
     * const control = new FormControl('bad@', Validators.email);
     *
     * console.log(control.errors); // {email: true}
     * ```
     *
     * @returns An error map with the `email` property
     * if the validation check fails, otherwise `null`.
     *
     */
    static email(control) {
        return super.email(control);
    }
    /**
     * Validator that requires the length of the control's value to be greater than or equal
     * to the provided minimum length. This validator is also provided by default if you use the
     * the HTML5 `minlength` attribute.
     *
     * ### Validate that the field has a minimum of 3 characters
     *
     * ```typescript
     * const control = new FormControl('ng', Validators.minLength(3));
     *
     * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}
     * ```
     *
     * ```html
     * <input minlength="5">
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `minlength` if the validation check fails, otherwise `null`.
     */
    static minLength(minLength) {
        return super.minLength(minLength);
    }
    /**
     * Validator that requires the length of the control's value to be less than or equal
     * to the provided maximum length. This validator is also provided by default if you use the
     * the HTML5 `maxlength` attribute.
     *
     * ### Validate that the field has maximum of 5 characters
     *
     * ```typescript
     * const control = new FormControl('Angular', Validators.maxLength(5));
     *
     * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}
     * ```
     *
     * ```html
     * <input maxlength="5">
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `maxlength` property if the validation check fails, otherwise `null`.
     */
    static maxLength(maxLength) {
        return super.maxLength(maxLength);
    }
    /**
     * Validator that requires the control's value to match a regex pattern. This validator is also
     * provided by default if you use the HTML5 `pattern` attribute.
     *
     * Note that if a Regexp is provided, the Regexp is used as is to test the values. On the other
     * hand, if a string is passed, the `^` character is prepended and the `$` character is
     * appended to the provided string (if not already present), and the resulting regular
     * expression is used to test the values.
     *
     * ### Validate that the field only contains letters or spaces
     *
     * ```typescript
     * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));
     *
     * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}
     * ```
     *
     * ```html
     * <input pattern="[a-zA-Z ]*">
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `pattern` property if the validation check fails, otherwise `null`.
     */
    static pattern(pattern) {
        return super.pattern(pattern);
    }
    /**
     * Validator that performs no operation.
     */
    static nullValidator(control) {
        return null;
    }
    static compose(validators) {
        return super.compose(validators);
    }
    /**
     * Compose multiple async validators into a single function that returns the union
     * of the individual error objects for the provided control.
     *
     * @returns A validator function that returns an error map with the
     * merged error objects of the async validators if the validation check fails, otherwise `null`.
     */
    static composeAsync(validators) {
        return super.composeAsync(validators);
    }
    /**
     * At least one file should be.
     *
     * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.
     */
    static fileRequired(formControl) {
        if (!(formControl.value instanceof FormData)) {
            return { fileRequired: true };
        }
        const files = [];
        formControl.value.forEach((file) => files.push(file));
        for (const file of files) {
            if (file instanceof File) {
                return null;
            }
        }
        return { fileRequired: true };
    }
    /**
     * Minimal number of files.
     *
     * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.
     */
    static filesMinLength(minLength) {
        return (formControl) => {
            const value = formControl.value;
            if (minLength < 1) {
                return null;
            }
            if (!value || !(value instanceof FormData)) {
                return { filesMinLength: { requiredLength: minLength, actualLength: 0 } };
            }
            const files = [];
            value.forEach((file) => files.push(file));
            const len = files.length;
            if (len < minLength) {
                return { filesMinLength: { requiredLength: minLength, actualLength: len } };
            }
            return null;
        };
    }
    /**
     * Maximal number of files.
     *
     * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.
     */
    static filesMaxLength(maxLength) {
        return (formControl) => {
            if (!(formControl.value instanceof FormData)) {
                return null;
            }
            const files = [];
            formControl.value.forEach((file) => files.push(file));
            const len = files.length;
            if (len > maxLength) {
                return { filesMaxLength: { requiredLength: maxLength, actualLength: len } };
            }
            return null;
        };
    }
    /**
     * Maximal size of a file.
     *
     * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.
     */
    static fileMaxSize(maxSize) {
        return (formControl) => {
            if (!(formControl.value instanceof FormData)) {
                return null;
            }
            const files = [];
            formControl.value.forEach((file) => files.push(file));
            for (const file of files) {
                if (file instanceof File && file.size > maxSize) {
                    return { fileMaxSize: { requiredSize: maxSize, actualSize: file.size, file } };
                }
            }
            return null;
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9ycy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLi8uLi9wcm9qZWN0cy9mb3Jtcy9zcmMvIiwic291cmNlcyI6WyJsaWIvdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxJQUFJLGdCQUFnQixFQUFtQixNQUFNLGdCQUFnQixDQUFDO0FBS2pGLDRHQUE0RztBQUM1RyxXQUFXO0FBQ1g7Ozs7Ozs7R0FPRztBQUNILE1BQU0sT0FBTyxVQUFXLFNBQVEsZ0JBQWdCO0lBQzlDOzs7Ozs7Ozs7Ozs7Ozs7T0FlRztJQUNILE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBVztRQUNwQixPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUEwRCxDQUFDO0lBQ2pGLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSCxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQVc7UUFDcEIsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBMEQsQ0FBQztJQUNqRixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7O09BY0c7SUFDSCxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQXdCO1FBQ3RDLE9BQU8sS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQWdELENBQUM7SUFDaEYsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBQ0gsTUFBTSxDQUFDLFlBQVksQ0FBQyxPQUF3QjtRQUMxQyxPQUFPLEtBQUssQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFnRCxDQUFDO0lBQ3BGLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7T0FjRztJQUNILE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBd0I7UUFDbkMsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBNkMsQ0FBQztJQUMxRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtQkc7SUFDSCxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQWlCO1FBQ2hDLE9BQU8sS0FB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IHsgVmFsaWRhdG9ycyBhcyBOYXRpdmVWYWxpZGF0b3JzLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IFZhbGlkYXRvckZuLCBWYWxpZGF0aW9uRXJyb3JzLCBBc3luY1ZhbGlkYXRvckZuIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCB9IGZyb20gJy4vZm9ybS1jb250cm9sJztcblxuLy8gTmV4dCBmbGFnIHVzZWQgYmVjYXVzZSBvZiB0aGlzIGh0dHBzOi8vZ2l0aHViLmNvbS9uZy1wYWNrYWdyL25nLXBhY2thZ3IvaXNzdWVzLzY5NiNpc3N1ZWNvbW1lbnQtMzczNDg3MTgzXG4vLyBAZHluYW1pY1xuLyoqXG4gKiBQcm92aWRlcyBhIHNldCBvZiBidWlsdC1pbiB2YWxpZGF0b3JzIHRoYXQgY2FuIGJlIHVzZWQgYnkgZm9ybSBjb250cm9scy5cbiAqXG4gKiBBIHZhbGlkYXRvciBpcyBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGEgYEZvcm1Db250cm9sYCBvciBjb2xsZWN0aW9uIG9mXG4gKiBjb250cm9scyBhbmQgcmV0dXJucyBhbiBlcnJvciBtYXAgb3IgbnVsbC4gQSBudWxsIG1hcCBtZWFucyB0aGF0IHZhbGlkYXRpb24gaGFzIHBhc3NlZC5cbiAqXG4gKiBTZWUgYWxzbyBbRm9ybSBWYWxpZGF0aW9uXShodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvZm9ybS12YWxpZGF0aW9uKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFZhbGlkYXRvcnMgZXh0ZW5kcyBOYXRpdmVWYWxpZGF0b3JzIHtcbiAgLyoqXG4gICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBudW1iZXIuXG4gICAqIFRoZSB2YWxpZGF0b3IgZXhpc3RzIG9ubHkgYXMgYSBmdW5jdGlvbiBhbmQgbm90IGFzIGEgZGlyZWN0aXZlLlxuICAgKlxuICAgKiAjIyMgVmFsaWRhdGUgYWdhaW5zdCBhIG1pbmltdW0gb2YgM1xuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBjb250cm9sID0gbmV3IEZvcm1Db250cm9sKDIsIFZhbGlkYXRvcnMubWluKDMpKTtcbiAgICpcbiAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7bWluOiB7bWluOiAzLCBhY3R1YWw6IDJ9fVxuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMgQSB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVycm9yIG1hcCB3aXRoIHRoZVxuICAgKiBgbWluYCBwcm9wZXJ0eSBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICpcbiAgICovXG4gIHN0YXRpYyBtaW4obWluOiBudW1iZXIpIHtcbiAgICByZXR1cm4gc3VwZXIubWluKG1pbikgYXMgVmFsaWRhdG9yRm48eyBtaW46IHsgbWluOiBudW1iZXI7IGFjdHVhbDogbnVtYmVyIH0gfT47XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGNvbnRyb2wncyB2YWx1ZSB0byBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG51bWJlci5cbiAgICogVGhlIHZhbGlkYXRvciBleGlzdHMgb25seSBhcyBhIGZ1bmN0aW9uIGFuZCBub3QgYXMgYSBkaXJlY3RpdmUuXG4gICAqXG4gICAqICMjIyBWYWxpZGF0ZSBhZ2FpbnN0IGEgbWF4aW11bSBvZiAxNVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBjb250cm9sID0gbmV3IEZvcm1Db250cm9sKDE2LCBWYWxpZGF0b3JzLm1heCgxNSkpO1xuICAgKlxuICAgKiBjb25zb2xlLmxvZyhjb250cm9sLmVycm9ycyk7IC8vIHttYXg6IHttYXg6IDE1LCBhY3R1YWw6IDE2fX1cbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIEEgdmFsaWRhdG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlcnJvciBtYXAgd2l0aCB0aGVcbiAgICogYG1heGAgcHJvcGVydHkgaWYgdGhlIHZhbGlkYXRpb24gY2hlY2sgZmFpbHMsIG90aGVyd2lzZSBgbnVsbGAuXG4gICAqXG4gICAqL1xuICBzdGF0aWMgbWF4KG1heDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHN1cGVyLm1heChtYXgpIGFzIFZhbGlkYXRvckZuPHsgbWF4OiB7IG1heDogbnVtYmVyOyBhY3R1YWw6IG51bWJlciB9IH0+O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250cm9sIGhhdmUgYSBub24tZW1wdHkgdmFsdWUuXG4gICAqXG4gICAqICMjIyBWYWxpZGF0ZSB0aGF0IHRoZSBmaWVsZCBpcyBub24tZW1wdHlcbiAgICpcbiAgICogYGBgdHNcbiAgICogY29uc3QgY29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKGNvbnRyb2wuZXJyb3JzKTsgLy8ge3JlcXVpcmVkOiB0cnVlfVxuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMgQW4gZXJyb3IgbWFwIHdpdGggdGhlIGByZXF1aXJlZGAgcHJvcGVydHlcbiAgICogaWYgdGhlIHZhbGlkYXRpb24gY2hlY2sgZmFpbHMsIG90aGVyd2lzZSBgbnVsbGAuXG4gICAqXG4gICAqL1xuICBzdGF0aWMgcmVxdWlyZWQoY29udHJvbDogQWJzdHJhY3RDb250cm9sKSB7XG4gICAgcmV0dXJuIHN1cGVyLnJlcXVpcmVkKGNvbnRyb2wpIGFzIFZhbGlkYXRpb25FcnJvcnM8eyByZXF1aXJlZDogdHJ1ZSB9PiB8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGNvbnRyb2wncyB2YWx1ZSBiZSB0cnVlLiBUaGlzIHZhbGlkYXRvciBpcyBjb21tb25seVxuICAgKiB1c2VkIGZvciByZXF1aXJlZCBjaGVja2JveGVzLlxuICAgKlxuICAgKiAjIyMgVmFsaWRhdGUgdGhhdCB0aGUgZmllbGQgdmFsdWUgaXMgdHJ1ZVxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJycsIFZhbGlkYXRvcnMucmVxdWlyZWRUcnVlKTtcbiAgICpcbiAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7cmVxdWlyZWQ6IHRydWV9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyBBbiBlcnJvciBtYXAgdGhhdCBjb250YWlucyB0aGUgYHJlcXVpcmVkYCBwcm9wZXJ0eVxuICAgKiBzZXQgdG8gYHRydWVgIGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLlxuICAgKi9cbiAgc3RhdGljIHJlcXVpcmVkVHJ1ZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpIHtcbiAgICByZXR1cm4gc3VwZXIucmVxdWlyZWRUcnVlKGNvbnRyb2wpIGFzIFZhbGlkYXRpb25FcnJvcnM8eyByZXF1aXJlZDogdHJ1ZSB9PiB8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGNvbnRyb2wncyB2YWx1ZSBwYXNzIGFuIGVtYWlsIHZhbGlkYXRpb24gdGVzdC5cbiAgICpcbiAgICogIyMjIFZhbGlkYXRlIHRoYXQgdGhlIGZpZWxkIG1hdGNoZXMgYSB2YWxpZCBlbWFpbCBwYXR0ZXJuXG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgnYmFkQCcsIFZhbGlkYXRvcnMuZW1haWwpO1xuICAgKlxuICAgKiBjb25zb2xlLmxvZyhjb250cm9sLmVycm9ycyk7IC8vIHtlbWFpbDogdHJ1ZX1cbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIGVycm9yIG1hcCB3aXRoIHRoZSBgZW1haWxgIHByb3BlcnR5XG4gICAqIGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLlxuICAgKlxuICAgKi9cbiAgc3RhdGljIGVtYWlsKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCkge1xuICAgIHJldHVybiBzdXBlci5lbWFpbChjb250cm9sKSBhcyBWYWxpZGF0aW9uRXJyb3JzPHsgZW1haWw6IHRydWUgfT4gfCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBsZW5ndGggb2YgdGhlIGNvbnRyb2wncyB2YWx1ZSB0byBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWxcbiAgICogdG8gdGhlIHByb3ZpZGVkIG1pbmltdW0gbGVuZ3RoLiBUaGlzIHZhbGlkYXRvciBpcyBhbHNvIHByb3ZpZGVkIGJ5IGRlZmF1bHQgaWYgeW91IHVzZSB0aGVcbiAgICogdGhlIEhUTUw1IGBtaW5sZW5ndGhgIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogIyMjIFZhbGlkYXRlIHRoYXQgdGhlIGZpZWxkIGhhcyBhIG1pbmltdW0gb2YgMyBjaGFyYWN0ZXJzXG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgnbmcnLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgzKSk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKGNvbnRyb2wuZXJyb3JzKTsgLy8ge21pbmxlbmd0aDoge3JlcXVpcmVkTGVuZ3RoOiAzLCBhY3R1YWxMZW5ndGg6IDJ9fVxuICAgKiBgYGBcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8aW5wdXQgbWlubGVuZ3RoPVwiNVwiPlxuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMgQSB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVycm9yIG1hcCB3aXRoIHRoZVxuICAgKiBgbWlubGVuZ3RoYCBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICovXG4gIHN0YXRpYyBtaW5MZW5ndGgobWluTGVuZ3RoOiBudW1iZXIpIHtcbiAgICByZXR1cm4gc3VwZXIubWluTGVuZ3RoKG1pbkxlbmd0aCkgYXMgVmFsaWRhdG9yRm48e1xuICAgICAgbWlubGVuZ3RoOiB7IHJlcXVpcmVkTGVuZ3RoOiBudW1iZXI7IGFjdHVhbExlbmd0aDogbnVtYmVyIH07XG4gICAgfT47XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGxlbmd0aCBvZiB0aGUgY29udHJvbCdzIHZhbHVlIHRvIGJlIGxlc3MgdGhhbiBvciBlcXVhbFxuICAgKiB0byB0aGUgcHJvdmlkZWQgbWF4aW11bSBsZW5ndGguIFRoaXMgdmFsaWRhdG9yIGlzIGFsc28gcHJvdmlkZWQgYnkgZGVmYXVsdCBpZiB5b3UgdXNlIHRoZVxuICAgKiB0aGUgSFRNTDUgYG1heGxlbmd0aGAgYXR0cmlidXRlLlxuICAgKlxuICAgKiAjIyMgVmFsaWRhdGUgdGhhdCB0aGUgZmllbGQgaGFzIG1heGltdW0gb2YgNSBjaGFyYWN0ZXJzXG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgnQW5ndWxhcicsIFZhbGlkYXRvcnMubWF4TGVuZ3RoKDUpKTtcbiAgICpcbiAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7bWF4bGVuZ3RoOiB7cmVxdWlyZWRMZW5ndGg6IDUsIGFjdHVhbExlbmd0aDogN319XG4gICAqIGBgYFxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxpbnB1dCBtYXhsZW5ndGg9XCI1XCI+XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyBBIHZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZXJyb3IgbWFwIHdpdGggdGhlXG4gICAqIGBtYXhsZW5ndGhgIHByb3BlcnR5IGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLlxuICAgKi9cbiAgc3RhdGljIG1heExlbmd0aChtYXhMZW5ndGg6IG51bWJlcikge1xuICAgIHJldHVybiBzdXBlci5tYXhMZW5ndGgobWF4TGVuZ3RoKSBhcyBWYWxpZGF0b3JGbjx7XG4gICAgICBtYXhsZW5ndGg6IHsgcmVxdWlyZWRMZW5ndGg6IG51bWJlcjsgYWN0dWFsTGVuZ3RoOiBudW1iZXIgfTtcbiAgICB9PjtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgY29udHJvbCdzIHZhbHVlIHRvIG1hdGNoIGEgcmVnZXggcGF0dGVybi4gVGhpcyB2YWxpZGF0b3IgaXMgYWxzb1xuICAgKiBwcm92aWRlZCBieSBkZWZhdWx0IGlmIHlvdSB1c2UgdGhlIEhUTUw1IGBwYXR0ZXJuYCBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiBhIFJlZ2V4cCBpcyBwcm92aWRlZCwgdGhlIFJlZ2V4cCBpcyB1c2VkIGFzIGlzIHRvIHRlc3QgdGhlIHZhbHVlcy4gT24gdGhlIG90aGVyXG4gICAqIGhhbmQsIGlmIGEgc3RyaW5nIGlzIHBhc3NlZCwgdGhlIGBeYCBjaGFyYWN0ZXIgaXMgcHJlcGVuZGVkIGFuZCB0aGUgYCRgIGNoYXJhY3RlciBpc1xuICAgKiBhcHBlbmRlZCB0byB0aGUgcHJvdmlkZWQgc3RyaW5nIChpZiBub3QgYWxyZWFkeSBwcmVzZW50KSwgYW5kIHRoZSByZXN1bHRpbmcgcmVndWxhclxuICAgKiBleHByZXNzaW9uIGlzIHVzZWQgdG8gdGVzdCB0aGUgdmFsdWVzLlxuICAgKlxuICAgKiAjIyMgVmFsaWRhdGUgdGhhdCB0aGUgZmllbGQgb25seSBjb250YWlucyBsZXR0ZXJzIG9yIHNwYWNlc1xuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJzEnLCBWYWxpZGF0b3JzLnBhdHRlcm4oJ1thLXpBLVogXSonKSk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKGNvbnRyb2wuZXJyb3JzKTsgLy8ge3BhdHRlcm46IHtyZXF1aXJlZFBhdHRlcm46ICdeW2EtekEtWiBdKiQnLCBhY3R1YWxWYWx1ZTogJzEnfX1cbiAgICogYGBgXG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGlucHV0IHBhdHRlcm49XCJbYS16QS1aIF0qXCI+XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyBBIHZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZXJyb3IgbWFwIHdpdGggdGhlXG4gICAqIGBwYXR0ZXJuYCBwcm9wZXJ0eSBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICovXG4gIHN0YXRpYyBwYXR0ZXJuKHBhdHRlcm46IHN0cmluZyB8IFJlZ0V4cCkge1xuICAgIHJldHVybiBzdXBlci5wYXR0ZXJuKHBhdHRlcm4pIGFzIFZhbGlkYXRvckZuPHtcbiAgICAgIHBhdHRlcm46IHsgcmVxdWlyZWRQYXR0ZXJuOiBzdHJpbmc7IGFjdHVhbFZhbHVlOiBzdHJpbmcgfTtcbiAgICB9PjtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0b3IgdGhhdCBwZXJmb3JtcyBubyBvcGVyYXRpb24uXG4gICAqL1xuICBzdGF0aWMgbnVsbFZhbGlkYXRvcihjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wb3NlIG11bHRpcGxlIHZhbGlkYXRvcnMgaW50byBhIHNpbmdsZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHVuaW9uXG4gICAqIG9mIHRoZSBpbmRpdmlkdWFsIGVycm9yIG1hcHMgZm9yIHRoZSBwcm92aWRlZCBjb250cm9sLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZXJyb3IgbWFwIHdpdGggdGhlXG4gICAqIG1lcmdlZCBlcnJvciBtYXBzIG9mIHRoZSB2YWxpZGF0b3JzIGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLlxuICAgKi9cbiAgc3RhdGljIGNvbXBvc2UodmFsaWRhdG9yczogbnVsbCk6IG51bGw7XG4gIHN0YXRpYyBjb21wb3NlPFQgZXh0ZW5kcyBvYmplY3QgPSBhbnk+KHZhbGlkYXRvcnM6IChWYWxpZGF0b3JGbiB8IG51bGwgfCB1bmRlZmluZWQpW10pOiBWYWxpZGF0b3JGbjxUPiB8IG51bGw7XG4gIHN0YXRpYyBjb21wb3NlPFQgZXh0ZW5kcyBvYmplY3QgPSBhbnk+KHZhbGlkYXRvcnM6IChWYWxpZGF0b3JGbiB8IG51bGwgfCB1bmRlZmluZWQpW10gfCBudWxsKTogVmFsaWRhdG9yRm48VD4gfCBudWxsIHtcbiAgICByZXR1cm4gc3VwZXIuY29tcG9zZSh2YWxpZGF0b3JzKSBhcyBWYWxpZGF0b3JGbjxUPiB8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ29tcG9zZSBtdWx0aXBsZSBhc3luYyB2YWxpZGF0b3JzIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB1bmlvblxuICAgKiBvZiB0aGUgaW5kaXZpZHVhbCBlcnJvciBvYmplY3RzIGZvciB0aGUgcHJvdmlkZWQgY29udHJvbC5cbiAgICpcbiAgICogQHJldHVybnMgQSB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVycm9yIG1hcCB3aXRoIHRoZVxuICAgKiBtZXJnZWQgZXJyb3Igb2JqZWN0cyBvZiB0aGUgYXN5bmMgdmFsaWRhdG9ycyBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICovXG4gIHN0YXRpYyBjb21wb3NlQXN5bmM8VCBleHRlbmRzIG9iamVjdCA9IGFueT4odmFsaWRhdG9yczogKEFzeW5jVmFsaWRhdG9yRm48VD4gfCBudWxsKVtdKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbXBvc2VBc3luYyh2YWxpZGF0b3JzKSBhcyBBc3luY1ZhbGlkYXRvckZuPFQ+IHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdCBsZWFzdCBvbmUgZmlsZSBzaG91bGQgYmUuXG4gICAqXG4gICAqICoqTm90ZSoqOiB1c2UgdGhpcyB2YWxpZGF0b3Igd2hlbiBgZm9ybUNvbnRyb2wudmFsdWVgIGlzIGFuIGluc3RhbmNlIG9mIGBGb3JtRGF0YWAgb25seS5cbiAgICovXG4gIHN0YXRpYyBmaWxlUmVxdWlyZWQoZm9ybUNvbnRyb2w6IEZvcm1Db250cm9sPEZvcm1EYXRhPik6IFZhbGlkYXRpb25FcnJvcnM8eyBmaWxlUmVxdWlyZWQ6IHRydWUgfT4gfCBudWxsIHtcbiAgICBpZiAoIShmb3JtQ29udHJvbC52YWx1ZSBpbnN0YW5jZW9mIEZvcm1EYXRhKSkge1xuICAgICAgcmV0dXJuIHsgZmlsZVJlcXVpcmVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZXM6IEZpbGVbXSA9IFtdO1xuICAgIGZvcm1Db250cm9sLnZhbHVlLmZvckVhY2goKGZpbGU6IEZpbGUpID0+IGZpbGVzLnB1c2goZmlsZSkpO1xuXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZmlsZVJlcXVpcmVkOiB0cnVlIH07XG4gIH1cblxuICAvKipcbiAgICogTWluaW1hbCBudW1iZXIgb2YgZmlsZXMuXG4gICAqXG4gICAqICoqTm90ZSoqOiB1c2UgdGhpcyB2YWxpZGF0b3Igd2hlbiBgZm9ybUNvbnRyb2wudmFsdWVgIGlzIGFuIGluc3RhbmNlIG9mIGBGb3JtRGF0YWAgb25seS5cbiAgICovXG4gIHN0YXRpYyBmaWxlc01pbkxlbmd0aChcbiAgICBtaW5MZW5ndGg6IG51bWJlclxuICApOiBWYWxpZGF0b3JGbjx7XG4gICAgZmlsZXNNaW5MZW5ndGg6IHsgcmVxdWlyZWRMZW5ndGg6IG51bWJlcjsgYWN0dWFsTGVuZ3RoOiBudW1iZXIgfTtcbiAgfT4ge1xuICAgIHJldHVybiAoZm9ybUNvbnRyb2w6IEZvcm1Db250cm9sPEZvcm1EYXRhPikgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBmb3JtQ29udHJvbC52YWx1ZTtcblxuICAgICAgaWYgKG1pbkxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmFsdWUgfHwgISh2YWx1ZSBpbnN0YW5jZW9mIEZvcm1EYXRhKSkge1xuICAgICAgICByZXR1cm4geyBmaWxlc01pbkxlbmd0aDogeyByZXF1aXJlZExlbmd0aDogbWluTGVuZ3RoLCBhY3R1YWxMZW5ndGg6IDAgfSB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWxlczogRmlsZVtdID0gW107XG4gICAgICB2YWx1ZS5mb3JFYWNoKChmaWxlOiBGaWxlKSA9PiBmaWxlcy5wdXNoKGZpbGUpKTtcbiAgICAgIGNvbnN0IGxlbiA9IGZpbGVzLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPCBtaW5MZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHsgZmlsZXNNaW5MZW5ndGg6IHsgcmVxdWlyZWRMZW5ndGg6IG1pbkxlbmd0aCwgYWN0dWFsTGVuZ3RoOiBsZW4gfSB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1heGltYWwgbnVtYmVyIG9mIGZpbGVzLlxuICAgKlxuICAgKiAqKk5vdGUqKjogdXNlIHRoaXMgdmFsaWRhdG9yIHdoZW4gYGZvcm1Db250cm9sLnZhbHVlYCBpcyBhbiBpbnN0YW5jZSBvZiBgRm9ybURhdGFgIG9ubHkuXG4gICAqL1xuICBzdGF0aWMgZmlsZXNNYXhMZW5ndGgoXG4gICAgbWF4TGVuZ3RoOiBudW1iZXJcbiAgKTogVmFsaWRhdG9yRm48e1xuICAgIGZpbGVzTWF4TGVuZ3RoOiB7IHJlcXVpcmVkTGVuZ3RoOiBudW1iZXI7IGFjdHVhbExlbmd0aDogbnVtYmVyIH07XG4gIH0+IHtcbiAgICByZXR1cm4gKGZvcm1Db250cm9sOiBGb3JtQ29udHJvbDxGb3JtRGF0YT4pID0+IHtcbiAgICAgIGlmICghKGZvcm1Db250cm9sLnZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGEpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWxlczogRmlsZVtdID0gW107XG4gICAgICBmb3JtQ29udHJvbC52YWx1ZS5mb3JFYWNoKChmaWxlOiBGaWxlKSA9PiBmaWxlcy5wdXNoKGZpbGUpKTtcbiAgICAgIGNvbnN0IGxlbiA9IGZpbGVzLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHsgZmlsZXNNYXhMZW5ndGg6IHsgcmVxdWlyZWRMZW5ndGg6IG1heExlbmd0aCwgYWN0dWFsTGVuZ3RoOiBsZW4gfSB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1heGltYWwgc2l6ZSBvZiBhIGZpbGUuXG4gICAqXG4gICAqICoqTm90ZSoqOiB1c2UgdGhpcyB2YWxpZGF0b3Igd2hlbiBgZm9ybUNvbnRyb2wudmFsdWVgIGlzIGFuIGluc3RhbmNlIG9mIGBGb3JtRGF0YWAgb25seS5cbiAgICovXG4gIHN0YXRpYyBmaWxlTWF4U2l6ZShcbiAgICBtYXhTaXplOiBudW1iZXJcbiAgKTogVmFsaWRhdG9yRm48e1xuICAgIGZpbGVNYXhTaXplOiB7IHJlcXVpcmVkU2l6ZTogbnVtYmVyOyBhY3R1YWxTaXplOiBudW1iZXI7IGZpbGU6IEZpbGUgfTtcbiAgfT4ge1xuICAgIHJldHVybiAoZm9ybUNvbnRyb2w6IEZvcm1Db250cm9sPEZvcm1EYXRhPikgPT4ge1xuICAgICAgaWYgKCEoZm9ybUNvbnRyb2wudmFsdWUgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpbGVzOiBGaWxlW10gPSBbXTtcbiAgICAgIGZvcm1Db250cm9sLnZhbHVlLmZvckVhY2goKGZpbGU6IEZpbGUpID0+IGZpbGVzLnB1c2goZmlsZSkpO1xuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgRmlsZSAmJiBmaWxlLnNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZmlsZU1heFNpemU6IHsgcmVxdWlyZWRTaXplOiBtYXhTaXplLCBhY3R1YWxTaXplOiBmaWxlLnNpemUsIGZpbGUgfSB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gIH1cbn1cbiJdfQ==