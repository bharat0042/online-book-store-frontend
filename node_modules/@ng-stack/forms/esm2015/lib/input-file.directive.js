import { Directive, ElementRef, Renderer2, HostListener, forwardRef, Input, Output, EventEmitter, HostBinding, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
export class InputFileDirective {
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.select = new EventEmitter();
        this.onChange = (value) => { };
        this.onTouched = () => { };
    }
    get multiple() {
        return this._multiple !== undefined && this._multiple !== false && this._multiple !== 'false' ? '' : undefined;
    }
    set multiple(value) {
        this._multiple = value;
    }
    /**
     * Callback function that should be called when
     * the control's value changes in the UI.
     */
    callOnChange(event) {
        this.onTouched();
        const files = Array.from(this.elementRef.nativeElement.files);
        const formData = new FormData();
        let formInputName = this.elementRef.nativeElement.name || 'uploadFile';
        if (this.multiple !== undefined && this.multiple !== false && this.multiple !== 'false') {
            formInputName += '[]';
        }
        files.forEach((file) => formData.append(formInputName, file));
        this.onChange(formData);
        this.select.next(files);
        if (this.preserveValue === undefined || this.preserveValue === false || this.preserveValue === 'false') {
            event.target.value = null;
        }
    }
    /**
     * Writes a new value to the element.
     * This method will be called by the forms API to write
     * to the view when programmatic (model -> view) changes are requested.
     *
     * See: [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor#members)
     */
    writeValue(fileList) {
        if (fileList && !(fileList instanceof FileList)) {
            throw new TypeError('Value for input[type=file] must be an instance of FileList');
        }
        this.renderer.setProperty(this.elementRef.nativeElement, 'files', fileList);
    }
    /**
     * Registers a callback function that should be called when
     * the control's value changes in the UI.
     *
     * This is called by the forms API on initialization so it can update
     * the form model when values propagate from the view (view -> model).
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * Registers a callback function that should be called when the control receives a change event.
     * This is called by the forms API on initialization so it can update the form model on change.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
}
InputFileDirective.decorators = [
    { type: Directive, args: [{
                selector: `
  input[type=file][ngModel],
  input[type=file][formControl],
  input[type=file][formControlName]`,
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => InputFileDirective), multi: true }],
            },] }
];
InputFileDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
InputFileDirective.propDecorators = {
    multiple: [{ type: HostBinding, args: ['attr.multiple',] }, { type: Input }],
    preserveValue: [{ type: HostBinding, args: ['attr.preserveValue',] }, { type: Input }],
    select: [{ type: Output }],
    callOnChange: [{ type: HostListener, args: ['change', ['$event'],] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtZmlsZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4vLi4vcHJvamVjdHMvZm9ybXMvc3JjLyIsInNvdXJjZXMiOlsibGliL2lucHV0LWZpbGUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFNBQVMsRUFDVCxZQUFZLEVBQ1osVUFBVSxFQUNWLEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFdBQVcsR0FDWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFTekUsTUFBTSxPQUFPLGtCQUFrQjtJQWE3QixZQUFvQixVQUFzQixFQUFVLFFBQW1CO1FBQW5ELGVBQVUsR0FBVixVQUFVLENBQVk7UUFBVSxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBSjdELFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO1FBQ3RDLGFBQVEsR0FBRyxDQUFDLEtBQWUsRUFBRSxFQUFFLEdBQUUsQ0FBQyxDQUFDO1FBQ25DLGNBQVMsR0FBRyxHQUFHLEVBQUUsR0FBRSxDQUFDLENBQUM7SUFFNkMsQ0FBQztJQVgzRSxJQUEyQyxRQUFRO1FBQ2pELE9BQU8sSUFBSSxDQUFDLFNBQVMsS0FBSyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQ2pILENBQUM7SUFDRCxJQUFJLFFBQVEsQ0FBQyxLQUF1QjtRQUNsQyxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztJQUN6QixDQUFDO0lBUUQ7OztPQUdHO0lBRUgsWUFBWSxDQUFDLEtBQVU7UUFDckIsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2pCLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEUsTUFBTSxRQUFRLEdBQUcsSUFBSSxRQUFRLEVBQUUsQ0FBQztRQUVoQyxJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxJQUFJLElBQUksWUFBWSxDQUFDO1FBQ3ZFLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxTQUFTLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxPQUFPLEVBQUU7WUFDdkYsYUFBYSxJQUFJLElBQUksQ0FBQztTQUN2QjtRQUNELEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFOUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4QixJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssS0FBSyxJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssT0FBTyxFQUFFO1lBQ3RHLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztTQUMzQjtJQUNILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxVQUFVLENBQUMsUUFBa0I7UUFDM0IsSUFBSSxRQUFRLElBQUksQ0FBQyxDQUFDLFFBQVEsWUFBWSxRQUFRLENBQUMsRUFBRTtZQUMvQyxNQUFNLElBQUksU0FBUyxDQUFDLDREQUE0RCxDQUFDLENBQUM7U0FDbkY7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDOUUsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILGdCQUFnQixDQUFDLEVBQWM7UUFDN0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7T0FHRztJQUNILGlCQUFpQixDQUFDLEVBQWM7UUFDOUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDdEIsQ0FBQzs7O1lBNUVGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUU7OztvQ0FHd0I7Z0JBQ2xDLFNBQVMsRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUM7YUFDNUc7OztZQWpCQyxVQUFVO1lBQ1YsU0FBUzs7O3VCQW1CUixXQUFXLFNBQUMsZUFBZSxjQUFHLEtBQUs7NEJBTW5DLFdBQVcsU0FBQyxvQkFBb0IsY0FBRyxLQUFLO3FCQUN4QyxNQUFNOzJCQVVOLFlBQVksU0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIFJlbmRlcmVyMixcbiAgSG9zdExpc3RlbmVyLFxuICBmb3J3YXJkUmVmLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBgXG4gIGlucHV0W3R5cGU9ZmlsZV1bbmdNb2RlbF0sXG4gIGlucHV0W3R5cGU9ZmlsZV1bZm9ybUNvbnRyb2xdLFxuICBpbnB1dFt0eXBlPWZpbGVdW2Zvcm1Db250cm9sTmFtZV1gLFxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJbnB1dEZpbGVEaXJlY3RpdmUpLCBtdWx0aTogdHJ1ZSB9XSxcbn0pXG5leHBvcnQgY2xhc3MgSW5wdXRGaWxlRGlyZWN0aXZlIGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICBwcml2YXRlIF9tdWx0aXBsZTogYm9vbGVhbiB8IHN0cmluZztcbiAgQEhvc3RCaW5kaW5nKCdhdHRyLm11bHRpcGxlJykgQElucHV0KCkgZ2V0IG11bHRpcGxlKCk6IGJvb2xlYW4gfCBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9tdWx0aXBsZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX211bHRpcGxlICE9PSBmYWxzZSAmJiB0aGlzLl9tdWx0aXBsZSAhPT0gJ2ZhbHNlJyA/ICcnIDogdW5kZWZpbmVkO1xuICB9XG4gIHNldCBtdWx0aXBsZSh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIHRoaXMuX211bHRpcGxlID0gdmFsdWU7XG4gIH1cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLnByZXNlcnZlVmFsdWUnKSBASW5wdXQoKSBwcmVzZXJ2ZVZhbHVlOiBib29sZWFuIHwgc3RyaW5nO1xuICBAT3V0cHV0KCkgc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcjxGaWxlW10+KCk7XG4gIHByaXZhdGUgb25DaGFuZ2UgPSAodmFsdWU6IEZvcm1EYXRhKSA9PiB7fTtcbiAgcHJpdmF0ZSBvblRvdWNoZWQgPSAoKSA9PiB7fTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdoZW5cbiAgICogdGhlIGNvbnRyb2wncyB2YWx1ZSBjaGFuZ2VzIGluIHRoZSBVSS5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2NoYW5nZScsIFsnJGV2ZW50J10pXG4gIGNhbGxPbkNoYW5nZShldmVudDogYW55KSB7XG4gICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgICBjb25zdCBmaWxlcyA9IEFycmF5LmZyb208RmlsZT4odGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZmlsZXMpO1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICBsZXQgZm9ybUlucHV0TmFtZSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm5hbWUgfHwgJ3VwbG9hZEZpbGUnO1xuICAgIGlmICh0aGlzLm11bHRpcGxlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5tdWx0aXBsZSAhPT0gZmFsc2UgJiYgdGhpcy5tdWx0aXBsZSAhPT0gJ2ZhbHNlJykge1xuICAgICAgZm9ybUlucHV0TmFtZSArPSAnW10nO1xuICAgIH1cbiAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiBmb3JtRGF0YS5hcHBlbmQoZm9ybUlucHV0TmFtZSwgZmlsZSkpO1xuXG4gICAgdGhpcy5vbkNoYW5nZShmb3JtRGF0YSk7XG4gICAgdGhpcy5zZWxlY3QubmV4dChmaWxlcyk7XG4gICAgaWYgKHRoaXMucHJlc2VydmVWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMucHJlc2VydmVWYWx1ZSA9PT0gZmFsc2UgfHwgdGhpcy5wcmVzZXJ2ZVZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICBldmVudC50YXJnZXQudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgYSBuZXcgdmFsdWUgdG8gdGhlIGVsZW1lbnQuXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBmb3JtcyBBUEkgdG8gd3JpdGVcbiAgICogdG8gdGhlIHZpZXcgd2hlbiBwcm9ncmFtbWF0aWMgKG1vZGVsIC0+IHZpZXcpIGNoYW5nZXMgYXJlIHJlcXVlc3RlZC5cbiAgICpcbiAgICogU2VlOiBbQ29udHJvbFZhbHVlQWNjZXNzb3JdKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvZm9ybXMvQ29udHJvbFZhbHVlQWNjZXNzb3IjbWVtYmVycylcbiAgICovXG4gIHdyaXRlVmFsdWUoZmlsZUxpc3Q6IEZpbGVMaXN0KTogdm9pZCB7XG4gICAgaWYgKGZpbGVMaXN0ICYmICEoZmlsZUxpc3QgaW5zdGFuY2VvZiBGaWxlTGlzdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGZvciBpbnB1dFt0eXBlPWZpbGVdIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRmlsZUxpc3QnKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2ZpbGVzJywgZmlsZUxpc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuXG4gICAqIHRoZSBjb250cm9sJ3MgdmFsdWUgY2hhbmdlcyBpbiB0aGUgVUkuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBmb3JtcyBBUEkgb24gaW5pdGlhbGl6YXRpb24gc28gaXQgY2FuIHVwZGF0ZVxuICAgKiB0aGUgZm9ybSBtb2RlbCB3aGVuIHZhbHVlcyBwcm9wYWdhdGUgZnJvbSB0aGUgdmlldyAodmlldyAtPiBtb2RlbCkuXG4gICAqL1xuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIHJlY2VpdmVzIGEgY2hhbmdlIGV2ZW50LlxuICAgKiBUaGlzIGlzIGNhbGxlZCBieSB0aGUgZm9ybXMgQVBJIG9uIGluaXRpYWxpemF0aW9uIHNvIGl0IGNhbiB1cGRhdGUgdGhlIGZvcm0gbW9kZWwgb24gY2hhbmdlLlxuICAgKi9cbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICB9XG59XG4iXX0=