{"version":3,"file":"ng-stack-forms.js","sources":["../../../projects/forms/src/lib/form-builder.ts","../../../projects/forms/src/lib/input-file.directive.ts","../../../projects/forms/src/lib/ng-stack-forms.module.ts","../../../projects/forms/src/lib/form-array.ts","../../../projects/forms/src/lib/form-control.ts","../../../projects/forms/src/lib/form-group.ts","../../../projects/forms/src/lib/validators.ts","../../../projects/forms/src/lib/types.ts","../../../../projects/forms/src/public_api.ts","../../../../projects/forms/src/ng-stack-forms.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { FormBuilder as NativeFormBuilder } from '@angular/forms';\n\nimport {\n  FbControlConfig,\n  LegacyControlOptions,\n  AbstractControlOptions,\n  ValidatorFn,\n  AsyncValidatorFn,\n  ValidatorsModel,\n  FormControlState,\n} from './types';\nimport { FormGroup } from './form-group';\nimport { FormControl } from './form-control';\nimport { FormArray } from './form-array';\n\n@Injectable()\nexport class FormBuilder extends NativeFormBuilder {\n  /**\n   * Construct a new `FormGroup` instance.\n   *\n   * @param controlsConfig A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param options Configuration options object for the `FormGroup`. The object can\n   * have two shapes:\n   *\n   * 1) `AbstractControlOptions` object (preferred), which consists of:\n   * - `validators`: A synchronous validator function, or an array of validator functions\n   * - `asyncValidators`: A single async validator or array of async validator functions\n   * - `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur' |\n   * submit')\n   *\n   * 2) Legacy configuration object, which consists of:\n   * - `validator`: A synchronous validator function, or an array of validator functions\n   * - `asyncValidator`: A single async validator or array of async validator functions\n   */\n  group<T extends object = any, V extends object = ValidatorsModel>(\n    controlsConfig: { [P in keyof T]: FbControlConfig<T[P], V> },\n    options: AbstractControlOptions | LegacyControlOptions | null = null\n  ): FormGroup<T, V> {\n    return super.group(controlsConfig, options) as FormGroup<T, V>;\n  }\n\n  /**\n   * @description\n   * Construct a new `FormControl` with the given state, validators and options.\n   *\n   * @param formState Initializes the control with an initial state value, or\n   * with an object that contains both a value and a disabled status.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains\n   * validation functions and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator\n   * functions.\n   *\n   * ### Initialize a control as disabled\n   *\n   * The following example returns a control with an initial value in a disabled state.\n```ts\nimport {Component, Inject} from '@angular/core';\nimport {FormBuilder, FormControl, FormGroup, Validators} from '@angular/forms';\n// ...\n@Component({\n  selector: 'app-disabled-form-control',\n  template: `\n    <input [formControl]=\"control\" placeholder=\"First\">\n  `\n})\nexport class DisabledFormControlComponent {\n  control: FormControl;\n\n  constructor(private fb: FormBuilder) {\n    this.control = fb.control({value: 'my val', disabled: true});\n  }\n}\n```\n   */\n  control<T = any, V extends object = ValidatorsModel>(\n    formState: FormControlState<T> = null,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ): FormControl<T, V> {\n    return super.control(formState, validatorOrOpts, asyncValidator) as FormControl<T, V>;\n  }\n\n  /**\n   * Constructs a new `FormArray` from the given array of configurations,\n   * validators and options.\n   *\n   * @param controlsConfig An array of child controls or control configs. Each\n   * child control is given an index when it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains\n   * validation functions and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator\n   * functions.\n   */\n  array<Item = any, V extends object = ValidatorsModel>(\n    controlsConfig: FbControlConfig<Item, V>[],\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ): FormArray<Item, V> {\n    return super.array(controlsConfig, validatorOrOpts, asyncValidator) as FormArray<Item, V>;\n  }\n}\n","import {\n  Directive,\n  ElementRef,\n  Renderer2,\n  HostListener,\n  forwardRef,\n  Input,\n  Output,\n  EventEmitter,\n  HostBinding,\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\n@Directive({\n  selector: `\n  input[type=file][ngModel],\n  input[type=file][formControl],\n  input[type=file][formControlName]`,\n  providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => InputFileDirective), multi: true }],\n})\nexport class InputFileDirective implements ControlValueAccessor {\n  private _multiple: boolean | string;\n  @HostBinding('attr.multiple') @Input() get multiple(): boolean | string {\n    return this._multiple !== undefined && this._multiple !== false && this._multiple !== 'false' ? '' : undefined;\n  }\n  set multiple(value: boolean | string) {\n    this._multiple = value;\n  }\n  @HostBinding('attr.preserveValue') @Input() preserveValue: boolean | string;\n  @Output() select = new EventEmitter<File[]>();\n  private onChange = (value: FormData) => {};\n  private onTouched = () => {};\n\n  constructor(private elementRef: ElementRef, private renderer: Renderer2) {}\n\n  /**\n   * Callback function that should be called when\n   * the control's value changes in the UI.\n   */\n  @HostListener('change', ['$event'])\n  callOnChange(event: any) {\n    this.onTouched();\n    const files = Array.from<File>(this.elementRef.nativeElement.files);\n    const formData = new FormData();\n\n    let formInputName = this.elementRef.nativeElement.name || 'uploadFile';\n    if (this.multiple !== undefined && this.multiple !== false && this.multiple !== 'false') {\n      formInputName += '[]';\n    }\n    files.forEach((file) => formData.append(formInputName, file));\n\n    this.onChange(formData);\n    this.select.next(files);\n    if (this.preserveValue === undefined || this.preserveValue === false || this.preserveValue === 'false') {\n      event.target.value = null;\n    }\n  }\n\n  /**\n   * Writes a new value to the element.\n   * This method will be called by the forms API to write\n   * to the view when programmatic (model -> view) changes are requested.\n   *\n   * See: [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor#members)\n   */\n  writeValue(fileList: FileList): void {\n    if (fileList && !(fileList instanceof FileList)) {\n      throw new TypeError('Value for input[type=file] must be an instance of FileList');\n    }\n    this.renderer.setProperty(this.elementRef.nativeElement, 'files', fileList);\n  }\n\n  /**\n   * Registers a callback function that should be called when\n   * the control's value changes in the UI.\n   *\n   * This is called by the forms API on initialization so it can update\n   * the form model when values propagate from the view (view -> model).\n   */\n  registerOnChange(fn: () => void): void {\n    this.onChange = fn;\n  }\n\n  /**\n   * Registers a callback function that should be called when the control receives a change event.\n   * This is called by the forms API on initialization so it can update the form model on change.\n   */\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { ReactiveFormsModule } from '@angular/forms';\n\nimport { FormBuilder } from './form-builder';\nimport { InputFileDirective } from './input-file.directive';\n\n@NgModule({\n  declarations: [InputFileDirective],\n  exports: [ReactiveFormsModule, InputFileDirective],\n  providers: [FormBuilder],\n})\nexport class NgStackFormsModule {}\n","import { FormArray as NativeFormArray } from '@angular/forms';\n\nimport { Observable } from 'rxjs';\n\nimport {\n  ControlType,\n  Status,\n  ValidatorFn,\n  AsyncValidatorFn,\n  ValidatorsModel,\n  ValidationErrors,\n  AbstractControlOptions,\n  StringKeys,\n  ExtractModelValue,\n  FormControlState,\n} from './types';\n\nexport class FormArray<Item = any, V extends object = ValidatorsModel> extends NativeFormArray {\n  readonly value: ExtractModelValue<Item>[];\n  readonly valueChanges: Observable<ExtractModelValue<Item>[]>;\n  readonly status: Status;\n  readonly statusChanges: Observable<Status>;\n  readonly errors: ValidationErrors<V> | null;\n\n  /**\n   * Creates a new `FormArray` instance.\n   *\n   * @param controls An array of child controls. Each child control is given an index\n   * where it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(\n    public controls: ControlType<Item, V>[],\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ) {\n    super(controls, validatorOrOpts, asyncValidator);\n  }\n\n  /**\n   * Get the Control at the given `index` in the array.\n   *\n   * @param index Index in the array to retrieve the control\n   */\n  at(index: number) {\n    return super.at(index) as ControlType<Item, V>;\n  }\n\n  /**\n   * Insert a new Control at the end of the array.\n   *\n   * @param control Form control to be inserted\n   */\n  push(control: ControlType<Item, V>) {\n    return super.push(control);\n  }\n\n  /**\n   * Insert a new Control at the given `index` in the array.\n   *\n   * @param index Index in the array to insert the control\n   * @param control Form control to be inserted\n   */\n  insert(index: number, control: ControlType<Item, V>) {\n    return super.insert(index, control);\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param index Index in the array to replace the control\n   * @param control The Control control to replace the existing control\n   */\n  setControl(index: number, control: ControlType<Item, V>) {\n    return super.setControl(index, control);\n  }\n\n  /**\n   * Sets the value of the `FormArray`. It accepts an array that matches\n   * the structure of the control.\n   *\n   * This method performs strict checks, and throws an error if you try\n   * to set the value of a control that doesn't exist or if you exclude the\n   * value of a control.\n   *\n   * ### Set the values for the controls in the form array\n   *\n```ts\nconst arr = new FormArray([\n  new FormControl(),\n  new FormControl()\n]);\nconsole.log(arr.value);   // [null, null]\n\narr.setValue(['Nancy', 'Drew']);\nconsole.log(arr.value);   // ['Nancy', 'Drew']\n```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   */\n  setValue(value: ExtractModelValue<Item>[], options: { onlySelf?: boolean; emitEvent?: boolean } = {}) {\n    return super.setValue(value, options);\n  }\n\n  /**\n   * Patches the value of the `FormArray`. It accepts an array that matches the\n   * structure of the control, and does its best to match the values to the correct\n   * controls in the group.\n   *\n   * It accepts both super-sets and sub-sets of the array without throwing an error.\n   *\n   * ### Patch the values for controls in a form array\n   *\n```ts\nconst arr = new FormArray([\n   new FormControl(),\n   new FormControl()\n]);\nconsole.log(arr.value);   // [null, null]\n\narr.patchValue(['Nancy']);\nconsole.log(arr.value);   // ['Nancy', null]\n```\n   *\n   * @param value Array of latest values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   */\n  patchValue(value: ExtractModelValue<Item>[], options: { onlySelf?: boolean; emitEvent?: boolean } = {}) {\n    return super.patchValue(value, options);\n  }\n\n  /**\n   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n   * value of all descendants to null or null maps.\n   *\n   * You reset to a specific form state by passing in an array of states\n   * that matches the structure of the control. The state is a standalone value\n   * or a form state object with both a value and a disabled status.\n   *\n   * ### Reset the values in a form array\n   *\n```ts\nconst arr = new FormArray([\n   new FormControl(),\n   new FormControl()\n]);\narr.reset(['name', 'last name']);\n\nconsole.log(this.arr.value);  // ['name', 'last name']\n```\n   *\n   * ### Reset the values in a form array and the disabled status for the first control\n   *\n```\nthis.arr.reset([\n  {value: 'name', disabled: true},\n  'last'\n]);\n\nconsole.log(this.arr.value);  // ['name', 'last name']\nconsole.log(this.arr.get(0).status);  // 'DISABLED'\n```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   */\n  reset(value: FormControlState<Item>[] = [], options: { onlySelf?: boolean; emitEvent?: boolean } = {}) {\n    return super.reset(value, options);\n  }\n\n  /**\n   * The aggregate value of the array, including any disabled controls.\n   *\n   * Reports all values regardless of disabled status.\n   * For enabled controls only, the `value` property is the best way to get the value of the array.\n   */\n  getRawValue() {\n    return super.getRawValue() as ExtractModelValue<Item>[];\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control. Calling\n   * this overwrites any existing sync validators.\n   */\n  setValidators(newValidator: ValidatorFn | ValidatorFn[] | null) {\n    return super.setValidators(newValidator);\n  }\n\n  /**\n   * Sets the async validators that are active on this control. Calling this\n   * overwrites any existing async validators.\n   */\n  setAsyncValidators(newValidator: AsyncValidatorFn | AsyncValidatorFn[] | null) {\n    return super.setAsyncValidators(newValidator);\n  }\n\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * ### Manually set the errors for a control\n   *\n   * ```ts\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n  setErrors(errors: ValidationErrors | null, opts: { emitEvent?: boolean } = {}) {\n    return super.setErrors(errors, opts);\n  }\n\n  /**\n   * Reports error data for the control with the given controlName.\n   *\n   * @param errorCode The code of the error to check\n   * @param controlName A control name that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * For example, for the following `FormGroup`:\n   *\n```ts\nform = new FormGroup({\n  address: new FormGroup({ street: new FormControl() })\n});\n```\n   *\n   * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in combination with `get()` method:\n   * \n```ts\nform.get('address').getError('someErrorCode', 'street');\n```\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n  getError<P extends StringKeys<V>, K extends StringKeys<Item>>(errorCode: P, controlName?: K) {\n    return super.getError(errorCode, controlName) as V[P] | null;\n  }\n\n  /**\n   * Reports whether the control with the given controlName has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param controlName A control name that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * For example, for the following `FormGroup`:\n   *\n```ts\nform = new FormGroup({\n  address: new FormGroup({ street: new FormControl() })\n});\n```\n   *\n   * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in combination with `get()` method:\n```ts\nform.get('address').hasError('someErrorCode', 'street');\n```\n   *\n   * If no controlName is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given controlName.\n   *\n   * If the control is not present, false is returned.\n   */\n  hasError<P extends StringKeys<V>, K extends StringKeys<Item>>(errorCode: P, controlName?: K) {\n    return super.hasError(errorCode, controlName);\n  }\n}\n","import { FormControl as NativeFormControl } from '@angular/forms';\n\nimport { Observable } from 'rxjs';\n\nimport {\n  Status,\n  ValidationErrors,\n  StringKeys,\n  ValidatorFn,\n  AsyncValidatorFn,\n  AbstractControlOptions,\n  ValidatorsModel,\n  ExtractControlValue,\n  FormControlState,\n} from './types';\n\nexport class FormControl<T = any, V extends object = ValidatorsModel> extends NativeFormControl {\n  readonly value: ExtractControlValue<T>;\n  readonly valueChanges: Observable<ExtractControlValue<T>>;\n  readonly status: Status;\n  readonly statusChanges: Observable<Status>;\n  readonly errors: ValidationErrors<V> | null;\n\n  /**\n   * Creates a new `FormControl` instance.\n   *\n   * @param formState Initializes the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(\n    formState: FormControlState<T> = null,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ) {\n    super(formState, validatorOrOpts, asyncValidator);\n  }\n\n  /**\n   * Sets a new value for the form control.\n   *\n   * @param value The new value for the control.\n   * @param options Configuration options that determine how the control proopagates changes\n   * and emits events when the value changes.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\n   * `onChange` event to\n   * update the view.\n   * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\n   * `ngModelChange`\n   * event to update the model.\n   *\n   */\n  setValue(\n    value: ExtractControlValue<T>,\n    options: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n      emitModelToViewChange?: boolean;\n      emitViewToModelChange?: boolean;\n    } = {}\n  ) {\n    return super.setValue(value, options);\n  }\n\n  /**\n   * Patches the value of a control.\n   *\n   * This function is functionally the same as [setValue](https://angular.io/api/forms/FormControl#setValue) at this level.\n   * It exists for symmetry with [patchValue](https://angular.io/api/forms/FormGroup#patchValue) on `FormGroups` and\n   * `FormArrays`, where it does behave differently.\n   *\n   * See also: `setValue` for options\n   */\n  patchValue(\n    value: ExtractControlValue<T>,\n    options: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n      emitModelToViewChange?: boolean;\n      emitViewToModelChange?: boolean;\n    } = {}\n  ) {\n    return super.patchValue(value, options);\n  }\n\n  /**\n   * Resets the form control, marking it `pristine` and `untouched`, and setting\n   * the value to null.\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   *\n   */\n  reset(\n    formState: FormControlState<T> = null,\n    options: {\n      onlySelf?: boolean;\n      emitEvent?: boolean;\n    } = {}\n  ) {\n    return super.reset(formState, options);\n  }\n\n  /**\n   * In `FormControl`, this method always returns `null`.\n   */\n  get(): null {\n    return null;\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control. Calling\n   * this overwrites any existing sync validators.\n   */\n  setValidators(newValidator: ValidatorFn | ValidatorFn[] | null) {\n    return super.setValidators(newValidator);\n  }\n\n  /**\n   * Sets the async validators that are active on this control. Calling this\n   * overwrites any existing async validators.\n   */\n  setAsyncValidators(newValidator: AsyncValidatorFn | AsyncValidatorFn[] | null) {\n    return super.setAsyncValidators(newValidator);\n  }\n\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * ### Manually set the errors for a control\n   *\n   * ```ts\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n  setErrors(errors: ValidationErrors | null, opts: { emitEvent?: boolean } = {}) {\n    return super.setErrors(errors, opts);\n  }\n\n  /**\n   * Reports error data for the current control.\n   *\n   * @param errorCode The code of the error to check.\n   *\n   * @returns error data for that particular error. If an error is not present,\n   * null is returned.\n   */\n  getError<K extends StringKeys<V> = any>(errorCode: K) {\n    return super.getError(errorCode) as V[K] | null;\n  }\n\n  /**\n   * Reports whether the current control has the error specified.\n   *\n   * @param errorCode The code of the error to check.\n   *\n   * @returns whether the given error is present in the current control.\n   *\n   * If an error is not present, false is returned.\n   */\n  hasError<K extends StringKeys<V> = any>(errorCode: K) {\n    return super.hasError(errorCode);\n  }\n}\n","import { FormGroup as NativeFormGroup } from '@angular/forms';\n\nimport { Observable } from 'rxjs';\n\nimport {\n  Status,\n  StringKeys,\n  ValidatorFn,\n  AsyncValidatorFn,\n  ValidatorsModel,\n  ValidationErrors,\n  AbstractControlOptions,\n  ControlType,\n  ExtractGroupValue,\n} from './types';\n\nexport class FormGroup<T extends object = any, V extends object = ValidatorsModel> extends NativeFormGroup {\n  readonly value: ExtractGroupValue<T>;\n  readonly valueChanges: Observable<ExtractGroupValue<T>>;\n  readonly status: Status;\n  readonly statusChanges: Observable<Status>;\n  readonly errors: ValidationErrors<V> | null;\n\n  /**\n   * Creates a new `FormGroup` instance.\n   *\n   * @param controls A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   * @todo Chechout how to respect optional and require properties modifyers for the controls.\n   */\n  constructor(\n    public controls: { [P in keyof T]: ControlType<T[P], V> },\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ) {\n    super(controls, validatorOrOpts, asyncValidator);\n  }\n\n  /**\n   * Registers a control with the group's list of controls.\n   *\n   * This method does not update the value or validity of the control.\n   * Use [addControl](https://angular.io/api/forms/FormGroup#addControl) instead.\n   *\n   * @param name The control name to register in the collection\n   * @param control Provides the control for the given name\n   */\n  registerControl<K extends StringKeys<T>, CV extends object = ValidatorsModel>(\n    name: K,\n    control: ControlType<T[K], CV>\n  ) {\n    return super.registerControl(name, control) as ControlType<T[K], CV>;\n  }\n\n  /**\n   * Add a control to this group.\n   *\n   * This method also updates the value and validity of the control.\n   *\n   * @param name The control name to add to the collection\n   * @param control Provides the control for the given name\n   */\n  addControl<K extends StringKeys<T>, CV extends object = ValidatorsModel>(name: K, control: ControlType<T[K], CV>) {\n    return super.addControl(name, control);\n  }\n\n  /**\n   * Remove a control from this group.\n   *\n   * @param name The control name to remove from the collection\n   */\n  removeControl<K extends StringKeys<T>>(name: K) {\n    return super.removeControl(name);\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param name The control name to replace in the collection\n   * @param control Provides the control for the given name\n   */\n  setControl<K extends StringKeys<T>, CV extends object = ValidatorsModel>(name: K, control: ControlType<T[K], CV>) {\n    return super.setControl(name, control);\n  }\n\n  /**\n   * Check whether there is an enabled control with the given name in the group.\n   *\n   * Reports false for disabled controls. If you'd like to check for existence in the group\n   * only, use [get](https://angular.io/api/forms/AbstractControl#get) instead.\n   *\n   * @param name The control name to check for existence in the collection\n   *\n   * @returns false for disabled controls, true otherwise.\n   */\n  contains<K extends StringKeys<T>>(name: K) {\n    return super.contains(name);\n  }\n\n  /**\n   * Sets the value of the `FormGroup`. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * ### Set the complete value for the form group\n   *\n```ts\nconst form = new FormGroup({\n  first: new FormControl(),\n  last: new FormControl()\n});\n\nconsole.log(form.value);   // {first: null, last: null}\n\nform.setValue({first: 'Nancy', last: 'Drew'});\nconsole.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n```\n   *\n   * @throws When strict checks fail, such as setting the value of a control\n   * that doesn't exist or if you excluding the value of a control.\n   *\n   * @param value The new value for the control that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   */\n  setValue(value: ExtractGroupValue<T>, options: { onlySelf?: boolean; emitEvent?: boolean } = {}) {\n    return super.setValue(value, options);\n  }\n\n  /**\n   * Patches the value of the `FormGroup`. It accepts an object with control\n   * names as keys, and does its best to match the values to the correct controls\n   * in the group.\n   *\n   * It accepts both super-sets and sub-sets of the group without throwing an error.\n   *\n   * ### Patch the value for a form group\n   *\n```ts\nconst form = new FormGroup({\n   first: new FormControl(),\n   last: new FormControl()\n});\nconsole.log(form.value);   // {first: null, last: null}\n\nform.patchValue({first: 'Nancy'});\nconsole.log(form.value);   // {first: 'Nancy', last: null}\n```\n   *\n   * @param value The object that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes and\n   * emits events after the value is patched.\n   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n   * true.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   */\n  patchValue(value: Partial<ExtractGroupValue<T>>, options: { onlySelf?: boolean; emitEvent?: boolean } = {}) {\n    return super.patchValue(value, options);\n  }\n\n  /**\n   * Resets the `FormGroup`, marks all descendants are marked `pristine` and `untouched`, and\n   * the value of all descendants to null.\n   *\n   * You reset to a specific form state by passing in a map of states\n   * that matches the structure of your form, with control names as keys. The state\n   * is a standalone value or a form state object with both a value and a disabled\n   * status.\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the group is reset.\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the\n   * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n   *\n   *\n   * ### Reset the form group values\n   *\n```ts\nconst form = new FormGroup({\n  first: new FormControl('first name'),\n  last: new FormControl('last name')\n});\n\nconsole.log(form.value);  // {first: 'first name', last: 'last name'}\n\nform.reset({ first: 'name', last: 'last name' });\n\nconsole.log(form.value);  // {first: 'name', last: 'last name'}\n```\n   *\n   * ### Reset the form group values and disabled status\n   *\n```ts\nconst form = new FormGroup({\n  first: new FormControl('first name'),\n  last: new FormControl('last name')\n});\n\nform.reset({\n  first: {value: 'name', disabled: true},\n  last: 'last'\n});\n\nconsole.log(this.form.value);  // {first: 'name', last: 'last name'}\nconsole.log(this.form.get('first').status);  // 'DISABLED'\n```\n   */\n  reset(value: ExtractGroupValue<T> = {} as any, options: { onlySelf?: boolean; emitEvent?: boolean } = {}) {\n    return super.reset(value, options);\n  }\n\n  /**\n   * The aggregate value of the `FormGroup`, including any disabled controls.\n   *\n   * Retrieves all values regardless of disabled status.\n   * The `value` property is the best way to get the value of the group, because\n   * it excludes disabled controls in the `FormGroup`.\n   */\n  getRawValue() {\n    return super.getRawValue() as ExtractGroupValue<T>;\n  }\n\n  /**\n   * Retrieves a child control given the control's name.\n   *\n   * ### Retrieve a nested control\n   *\n   * For example, to get a `name` control nested within a `person` sub-group:\n```ts\nthis.form.get('person').get('name');\n```\n   */\n  get<K extends StringKeys<T>, CV extends object = ValidatorsModel>(controlName: K): ControlType<T[K], CV> | null {\n    return super.get(controlName) as ControlType<T[K], CV> | null;\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control. Calling\n   * this overwrites any existing sync validators.\n   */\n  setValidators(newValidator: ValidatorFn | ValidatorFn[] | null) {\n    return super.setValidators(newValidator);\n  }\n\n  /**\n   * Sets the async validators that are active on this control. Calling this\n   * overwrites any existing async validators.\n   */\n  setAsyncValidators(newValidator: AsyncValidatorFn | AsyncValidatorFn[] | null) {\n    return super.setAsyncValidators(newValidator);\n  }\n\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * ### Manually set the errors for a control\n   *\n   * ```ts\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n  setErrors(errors: ValidationErrors | null, opts: { emitEvent?: boolean } = {}) {\n    return super.setErrors(errors, opts);\n  }\n\n  /**\n   * Reports error data for the control with the given controlName.\n   *\n   * @param errorCode The code of the error to check\n   * @param controlName A control name that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * For example, for the following `FormGroup`:\n   *\n```ts\nform = new FormGroup({\n  address: new FormGroup({ street: new FormControl() })\n});\n```\n   *\n   * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in combination with `get()` method:\n   * \n```ts\nform.get('address').getError('someErrorCode', 'street');\n```\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n  getError<P extends StringKeys<V>, K extends StringKeys<T>>(errorCode: P, controlName?: K) {\n    return super.getError(errorCode, controlName) as V[P] | null;\n  }\n\n  /**\n   * Reports whether the control with the given controlName has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param controlName A control name that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * For example, for the following `FormGroup`:\n   *\n```ts\nform = new FormGroup({\n  address: new FormGroup({ street: new FormControl() })\n});\n```\n   *\n   * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in combination with `get()` method:\n```ts\nform.get('address').hasError('someErrorCode', 'street');\n```\n   *\n   * If no controlName is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given controlName.\n   *\n   * If the control is not present, false is returned.\n   */\n  hasError<P extends StringKeys<V>, K extends StringKeys<T>>(errorCode: P, controlName?: K) {\n    return super.hasError(errorCode, controlName);\n  }\n}\n","import { Validators as NativeValidators, AbstractControl } from '@angular/forms';\n\nimport { ValidatorFn, ValidationErrors, AsyncValidatorFn } from './types';\nimport { FormControl } from './form-control';\n\n// Next flag used because of this https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-373487183\n// @dynamic\n/**\n * Provides a set of built-in validators that can be used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns an error map or null. A null map means that validation has passed.\n *\n * See also [Form Validation](https://angular.io/guide/form-validation).\n */\nexport class Validators extends NativeValidators {\n  /**\n   * Validator that requires the control's value to be greater than or equal to the provided number.\n   * The validator exists only as a function and not as a directive.\n   *\n   * ### Validate against a minimum of 3\n   *\n   * ```ts\n   * const control = new FormControl(2, Validators.min(3));\n   *\n   * console.log(control.errors); // {min: {min: 3, actual: 2}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `min` property if the validation check fails, otherwise `null`.\n   *\n   */\n  static min(min: number) {\n    return super.min(min) as ValidatorFn<{ min: { min: number; actual: number } }>;\n  }\n\n  /**\n   * Validator that requires the control's value to be less than or equal to the provided number.\n   * The validator exists only as a function and not as a directive.\n   *\n   * ### Validate against a maximum of 15\n   *\n   * ```ts\n   * const control = new FormControl(16, Validators.max(15));\n   *\n   * console.log(control.errors); // {max: {max: 15, actual: 16}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `max` property if the validation check fails, otherwise `null`.\n   *\n   */\n  static max(max: number) {\n    return super.max(max) as ValidatorFn<{ max: { max: number; actual: number } }>;\n  }\n\n  /**\n   * Validator that requires the control have a non-empty value.\n   *\n   * ### Validate that the field is non-empty\n   *\n   * ```ts\n   * const control = new FormControl('', Validators.required);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map with the `required` property\n   * if the validation check fails, otherwise `null`.\n   *\n   */\n  static required(control: AbstractControl) {\n    return super.required(control) as ValidationErrors<{ required: true }> | null;\n  }\n\n  /**\n   * Validator that requires the control's value be true. This validator is commonly\n   * used for required checkboxes.\n   *\n   * ### Validate that the field value is true\n   *\n   * ```typescript\n   * const control = new FormControl('', Validators.requiredTrue);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map that contains the `required` property\n   * set to `true` if the validation check fails, otherwise `null`.\n   */\n  static requiredTrue(control: AbstractControl) {\n    return super.requiredTrue(control) as ValidationErrors<{ required: true }> | null;\n  }\n\n  /**\n   * Validator that requires the control's value pass an email validation test.\n   *\n   * ### Validate that the field matches a valid email pattern\n   *\n   * ```typescript\n   * const control = new FormControl('bad@', Validators.email);\n   *\n   * console.log(control.errors); // {email: true}\n   * ```\n   *\n   * @returns An error map with the `email` property\n   * if the validation check fails, otherwise `null`.\n   *\n   */\n  static email(control: AbstractControl) {\n    return super.email(control) as ValidationErrors<{ email: true }> | null;\n  }\n\n  /**\n   * Validator that requires the length of the control's value to be greater than or equal\n   * to the provided minimum length. This validator is also provided by default if you use the\n   * the HTML5 `minlength` attribute.\n   *\n   * ### Validate that the field has a minimum of 3 characters\n   *\n   * ```typescript\n   * const control = new FormControl('ng', Validators.minLength(3));\n   *\n   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n   * ```\n   *\n   * ```html\n   * <input minlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `minlength` if the validation check fails, otherwise `null`.\n   */\n  static minLength(minLength: number) {\n    return super.minLength(minLength) as ValidatorFn<{\n      minlength: { requiredLength: number; actualLength: number };\n    }>;\n  }\n\n  /**\n   * Validator that requires the length of the control's value to be less than or equal\n   * to the provided maximum length. This validator is also provided by default if you use the\n   * the HTML5 `maxlength` attribute.\n   *\n   * ### Validate that the field has maximum of 5 characters\n   *\n   * ```typescript\n   * const control = new FormControl('Angular', Validators.maxLength(5));\n   *\n   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n   * ```\n   *\n   * ```html\n   * <input maxlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `maxlength` property if the validation check fails, otherwise `null`.\n   */\n  static maxLength(maxLength: number) {\n    return super.maxLength(maxLength) as ValidatorFn<{\n      maxlength: { requiredLength: number; actualLength: number };\n    }>;\n  }\n\n  /**\n   * Validator that requires the control's value to match a regex pattern. This validator is also\n   * provided by default if you use the HTML5 `pattern` attribute.\n   *\n   * Note that if a Regexp is provided, the Regexp is used as is to test the values. On the other\n   * hand, if a string is passed, the `^` character is prepended and the `$` character is\n   * appended to the provided string (if not already present), and the resulting regular\n   * expression is used to test the values.\n   *\n   * ### Validate that the field only contains letters or spaces\n   *\n   * ```typescript\n   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n   *\n   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n   * ```\n   *\n   * ```html\n   * <input pattern=\"[a-zA-Z ]*\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `pattern` property if the validation check fails, otherwise `null`.\n   */\n  static pattern(pattern: string | RegExp) {\n    return super.pattern(pattern) as ValidatorFn<{\n      pattern: { requiredPattern: string; actualValue: string };\n    }>;\n  }\n\n  /**\n   * Validator that performs no operation.\n   */\n  static nullValidator(control: AbstractControl): null {\n    return null;\n  }\n\n  /**\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error maps of the validators if the validation check fails, otherwise `null`.\n   */\n  static compose(validators: null): null;\n  static compose<T extends object = any>(validators: (ValidatorFn | null | undefined)[]): ValidatorFn<T> | null;\n  static compose<T extends object = any>(validators: (ValidatorFn | null | undefined)[] | null): ValidatorFn<T> | null {\n    return super.compose(validators) as ValidatorFn<T> | null;\n  }\n\n  /**\n   * Compose multiple async validators into a single function that returns the union\n   * of the individual error objects for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error objects of the async validators if the validation check fails, otherwise `null`.\n   */\n  static composeAsync<T extends object = any>(validators: (AsyncValidatorFn<T> | null)[]) {\n    return super.composeAsync(validators) as AsyncValidatorFn<T> | null;\n  }\n\n  /**\n   * At least one file should be.\n   *\n   * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n   */\n  static fileRequired(formControl: FormControl<FormData>): ValidationErrors<{ fileRequired: true }> | null {\n    if (!(formControl.value instanceof FormData)) {\n      return { fileRequired: true };\n    }\n\n    const files: File[] = [];\n    formControl.value.forEach((file: File) => files.push(file));\n\n    for (const file of files) {\n      if (file instanceof File) {\n        return null;\n      }\n    }\n\n    return { fileRequired: true };\n  }\n\n  /**\n   * Minimal number of files.\n   *\n   * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n   */\n  static filesMinLength(\n    minLength: number\n  ): ValidatorFn<{\n    filesMinLength: { requiredLength: number; actualLength: number };\n  }> {\n    return (formControl: FormControl<FormData>) => {\n      const value = formControl.value;\n\n      if (minLength < 1) {\n        return null;\n      }\n\n      if (!value || !(value instanceof FormData)) {\n        return { filesMinLength: { requiredLength: minLength, actualLength: 0 } };\n      }\n\n      const files: File[] = [];\n      value.forEach((file: File) => files.push(file));\n      const len = files.length;\n      if (len < minLength) {\n        return { filesMinLength: { requiredLength: minLength, actualLength: len } };\n      }\n\n      return null;\n    };\n  }\n\n  /**\n   * Maximal number of files.\n   *\n   * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n   */\n  static filesMaxLength(\n    maxLength: number\n  ): ValidatorFn<{\n    filesMaxLength: { requiredLength: number; actualLength: number };\n  }> {\n    return (formControl: FormControl<FormData>) => {\n      if (!(formControl.value instanceof FormData)) {\n        return null;\n      }\n\n      const files: File[] = [];\n      formControl.value.forEach((file: File) => files.push(file));\n      const len = files.length;\n      if (len > maxLength) {\n        return { filesMaxLength: { requiredLength: maxLength, actualLength: len } };\n      }\n\n      return null;\n    };\n  }\n\n  /**\n   * Maximal size of a file.\n   *\n   * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n   */\n  static fileMaxSize(\n    maxSize: number\n  ): ValidatorFn<{\n    fileMaxSize: { requiredSize: number; actualSize: number; file: File };\n  }> {\n    return (formControl: FormControl<FormData>) => {\n      if (!(formControl.value instanceof FormData)) {\n        return null;\n      }\n\n      const files: File[] = [];\n      formControl.value.forEach((file: File) => files.push(file));\n      for (const file of files) {\n        if (file instanceof File && file.size > maxSize) {\n          return { fileMaxSize: { requiredSize: maxSize, actualSize: file.size, file } };\n        }\n      }\n\n      return null;\n    };\n  }\n}\n","import { AbstractControl } from '@angular/forms';\n\nimport { Observable } from 'rxjs';\n\nimport { FormArray } from './form-array';\nimport { FormGroup } from './form-group';\nimport { FormControl } from './form-control';\n\n/**\n * This type marks a property of a form model as property\n * which is intended for an instance of `FormControl`.\n *\n * If a property of your form model have a primitive type,\n * in appropriate form field the instance of `FormControl` will be automatically assigned.\n * But if the property have a type that extends `object` - you need `Control<T>`.\n *\n * ### Example:\n```ts\nimport { FormBuilder, Control } from '@ng-stack/forms';\n\nconst fb = new FormBuilder();\n\n// Form Model\ninterface Person {\n  id: number;\n  name: string;\n  birthDate: Control<Date>; // Here should be FormControl, instead of a FormGroup\n}\n\nconst form = fb.group<Person>({\n  id: 123,\n  name: 'John Smith',\n  birthDate: new Date(1977, 6, 30),\n});\n\nconst birthDate: Date = form.value.birthDate;\n```\n * ## External form model\n * \n * If the form model interface comes from an external library, you can do the following:\n *\n```ts\nimport { FormBuilder, Control } from '@ng-stack/forms';\n\nconst fb = new FormBuilder();\n\n// External Form Model\ninterface ExternalPerson {\n  id: number;\n  name: string;\n  birthDate: Date;\n}\n\nconst configForm: ExternalPerson = {\n  id: 123,\n  name: 'John Smith',\n  birthDate: new Date(1977, 6, 30),\n};\n\ninterface Person extends ExternalPerson {\n  birthDate: Control<Date>;\n}\n\nconst form = fb.group<Person>(configForm); // `Control<Date>` type is compatible with `Date` type.\n\nconst birthDate: Date = form.value.birthDate; // `Control<Date>` type is compatible with `Date` type.\n```\n */\nexport type Control<T extends object> = T & UniqToken;\n\nconst sym = Symbol();\n\ninterface UniqToken {\n  [sym]: never;\n}\n\n/**\n * Extract `keyof T` with string keys.\n */\nexport type StringKeys<T> = Extract<keyof T, string>;\n\ntype ExtractAny<T> = T extends Extract<T, string & number & boolean & object & null & undefined> ? any : never;\n\n/**\n * This type is a conditional type that automatically detects\n * appropriate types for form controls by given type for its generic.\n */\nexport type ControlType<T, V extends object = ValidatorsModel> = [T] extends [ExtractAny<T>]\n  ? FormGroup<any, V> | FormControl<any, V> | FormArray<any, V>\n  : [T] extends [Control<infer ControlModel>]\n  ? FormControl<ControlModel, V>\n  : [T] extends [Array<infer Item>]\n  ? FormArray<Item, V>\n  : [T] extends [object]\n  ? FormGroup<T, V>\n  : FormControl<T, V>;\n\nexport type FormControlState<T> =\n  | null\n  | ExtractModelValue<T>\n  | {\n      value: null | ExtractModelValue<T>;\n      disabled: boolean;\n    };\n\n/**\n * Clears the form model from `Control<T>` type.\n */\nexport type ExtractModelValue<T> = [T] extends [ExtractAny<T>]\n  ? any\n  : [T] extends [Array<infer Item>]\n  ? Array<ExtractModelValue<Item>>\n  : [T] extends [Control<infer ControlModel>]\n  ? ControlModel\n  : [T] extends [object]\n  ? ExtractGroupValue<T>\n  : T;\n\nexport type ExtractControlValue<T> = [T] extends [Control<infer ControlModel>] ? ControlModel : T;\n\n/**\n * Clears the form model (as object) from `Control<T>` type.\n */\nexport type ExtractGroupValue<T extends object> = {\n  [P in keyof T]: ExtractModelValue<T[P]>;\n};\n\nexport type ExtractGroupStateValue<T extends object> = {\n  [P in keyof T]: FormControlState<T[P]>;\n};\n\n/**\n * Form builder control config.\n */\nexport type FbControlConfig<T, V extends object = ValidatorsModel> = [T] extends [ExtractAny<T>]\n  ? FormGroup<any, V> | FbControl<any, V> | FormArray<any, V>\n  : [T] extends [Control<infer ControlModel>]\n  ? FbControl<ControlModel, V>\n  : [T] extends [Array<infer Item>]\n  ? FormArray<Item, V>\n  : [T] extends [object]\n  ? FormGroup<T, V>\n  : FbControl<T, V>;\n\n/**\n * Form builder control.\n */\nexport type FbControl<T, V extends object = ValidatorsModel> =\n  | ExtractModelValue<T>\n  | FormControlState<T>\n  | [\n      FormControlState<T>,\n      (ValidatorFn | ValidatorFn[] | AbstractControlOptions)?,\n      (AsyncValidatorFn | AsyncValidatorFn[])?\n    ]\n  | FormControl<T, V>;\n\n/**\n * The validation status of the control. There are four possible\n * validation status values:\n *\n * * **VALID**: This control has passed all validation checks.\n * * **INVALID**: This control has failed at least one validation check.\n * * **PENDING**: This control is in the midst of conducting a validation check.\n * * **DISABLED**: This control is exempt from validation checks.\n *\n * These status values are mutually exclusive, so a control cannot be\n * both valid AND invalid or invalid AND disabled.\n */\nexport type Status = 'VALID' | 'INVALID' | 'PENDING' | 'DISABLED';\n\n/**\n * Interface for options provided to an `AbstractControl`.\n */\nexport interface AbstractControlOptions<T extends object = any> {\n  /**\n   * The list of validators applied to a control.\n   */\n  validators?: ValidatorFn<T> | ValidatorFn<T>[] | null;\n  /**\n   * The list of async validators applied to control.\n   */\n  asyncValidators?: AsyncValidatorFn<T> | AsyncValidatorFn<T>[] | null;\n  /**\n   * The event name for control to update upon.\n   */\n  updateOn?: 'change' | 'blur' | 'submit';\n}\n\n/**\n * Form builder legacy control options.\n */\nexport interface LegacyControlOptions {\n  validator: ValidatorFn | ValidatorFn[] | null;\n  asyncValidator: AsyncValidatorFn | AsyncValidatorFn[] | null;\n}\n\n/**\n * A function that receives a control and synchronously returns a map of\n * validation errors if present, otherwise null.\n */\nexport type ValidatorFn<T extends object = any> = (control: AbstractControl) => ValidationErrors<T> | null;\n\n/**\n * A function that receives a control and returns a Promise or observable\n * that emits validation errors if present, otherwise null.\n */\nexport type AsyncValidatorFn<T extends object = any> = (\n  control: AbstractControl\n) => Promise<ValidationErrors<T> | null> | Observable<ValidationErrors<T> | null>;\n\n/**\n * Defines the map of errors returned from failed validation checks.\n */\nexport type ValidationErrors<T extends object = any> = T;\n\n/**\n * The default validators model, it includes almost all static properties of `Validators`,\n * excludes: `prototype`, `compose`, `composeAsync` and `nullValidator`.\n *\n * ### Usage\n *\n```ts\nconst formControl = new FormControl<string, ValidatorsModel>('some value');\n// OR\nconst formGroup = new FormGroup<any, ValidatorsModel>({});\n// OR\nconst formArray = new FormArray<any, ValidatorsModel>([]);\n```\n */\nexport class ValidatorsModel {\n  min: { min: number; actual: number };\n  max: { max: number; actual: number };\n  required: true;\n  email: true;\n  minlength: { requiredLength: number; actualLength: number };\n  maxlength: { requiredLength: number; actualLength: number };\n  pattern: { requiredPattern: string; actualValue: string };\n  fileRequired: { requiredSize: number; actualSize: number; file: File };\n  filesMinLength: { requiredLength: number; actualLength: number };\n  filesMaxLength: { requiredLength: number; actualLength: number };\n  fileMaxSize: { requiredSize: number; actualSize: number; file: File };\n}\n","/*\n * Public API Surface of forms\n */\nexport { NgStackFormsModule } from './lib/ng-stack-forms.module';\nexport { FormArray } from './lib/form-array';\nexport { FormBuilder } from './lib/form-builder';\nexport { FormControl } from './lib/form-control';\nexport { FormGroup } from './lib/form-group';\nexport { Validators } from './lib/validators';\nexport { InputFileDirective } from './lib/input-file.directive';\nexport {\n  Status,\n  ValidatorFn,\n  AsyncValidatorFn,\n  ValidationErrors,\n  AbstractControlOptions,\n  ValidatorsModel,\n  Control,\n  ExtractModelValue,\n} from './lib/types';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n\nexport {ControlType as ɵa,FormControlState as ɵb} from './lib/types';"],"names":["NativeFormBuilder","NativeFormArray","NativeFormControl","NativeFormGroup","NativeValidators"],"mappings":";;;MAiBa,WAAY,SAAQA,aAAiB;;;;;;;;;;;;;;;;;;;;IAoBhD,KAAK,CACH,cAA4D,EAC5D,UAAgE,IAAI;QAEpE,OAAO,KAAK,CAAC,KAAK,CAAC,cAAc,EAAE,OAAO,CAAoB,CAAC;KAChE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAsCD,OAAO,CACL,YAAiC,IAAI,EACrC,eAA6E,EAC7E,cAA6D;QAE7D,OAAO,KAAK,CAAC,OAAO,CAAC,SAAS,EAAE,eAAe,EAAE,cAAc,CAAsB,CAAC;KACvF;;;;;;;;;;;;;;;IAgBD,KAAK,CACH,cAA0C,EAC1C,eAA6E,EAC7E,cAA6D;QAE7D,OAAO,KAAK,CAAC,KAAK,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAuB,CAAC;KAC3F;;;YA5FF,UAAU;;;MCIE,kBAAkB;IAa7B,YAAoB,UAAsB,EAAU,QAAmB;QAAnD,eAAU,GAAV,UAAU,CAAY;QAAU,aAAQ,GAAR,QAAQ,CAAW;QAJ7D,WAAM,GAAG,IAAI,YAAY,EAAU,CAAC;QACtC,aAAQ,GAAG,CAAC,KAAe,QAAO,CAAC;QACnC,cAAS,GAAG,SAAQ,CAAC;KAE8C;IAX3E,IAA2C,QAAQ;QACjD,OAAO,IAAI,CAAC,SAAS,KAAK,SAAS,IAAI,IAAI,CAAC,SAAS,KAAK,KAAK,IAAI,IAAI,CAAC,SAAS,KAAK,OAAO,GAAG,EAAE,GAAG,SAAS,CAAC;KAChH;IACD,IAAI,QAAQ,CAAC,KAAuB;QAClC,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;KACxB;;;;;IAaD,YAAY,CAAC,KAAU;QACrB,IAAI,CAAC,SAAS,EAAE,CAAC;QACjB,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAO,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QACpE,MAAM,QAAQ,GAAG,IAAI,QAAQ,EAAE,CAAC;QAEhC,IAAI,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,IAAI,YAAY,CAAC;QACvE,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,IAAI,IAAI,CAAC,QAAQ,KAAK,KAAK,IAAI,IAAI,CAAC,QAAQ,KAAK,OAAO,EAAE;YACvF,aAAa,IAAI,IAAI,CAAC;SACvB;QACD,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,KAAK,QAAQ,CAAC,MAAM,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC,CAAC;QAE9D,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACxB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACxB,IAAI,IAAI,CAAC,aAAa,KAAK,SAAS,IAAI,IAAI,CAAC,aAAa,KAAK,KAAK,IAAI,IAAI,CAAC,aAAa,KAAK,OAAO,EAAE;YACtG,KAAK,CAAC,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC;SAC3B;KACF;;;;;;;;IASD,UAAU,CAAC,QAAkB;QAC3B,IAAI,QAAQ,IAAI,EAAE,QAAQ,YAAY,QAAQ,CAAC,EAAE;YAC/C,MAAM,IAAI,SAAS,CAAC,4DAA4D,CAAC,CAAC;SACnF;QACD,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;KAC7E;;;;;;;;IASD,gBAAgB,CAAC,EAAc;QAC7B,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;KACpB;;;;;IAMD,iBAAiB,CAAC,EAAc;QAC9B,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;KACrB;;;YA5EF,SAAS,SAAC;gBACT,QAAQ,EAAE;;;oCAGwB;gBAClC,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,iBAAiB,EAAE,WAAW,EAAE,UAAU,CAAC,MAAM,kBAAkB,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC;aAC5G;;;YAjBC,UAAU;YACV,SAAS;;;uBAmBR,WAAW,SAAC,eAAe,cAAG,KAAK;4BAMnC,WAAW,SAAC,oBAAoB,cAAG,KAAK;qBACxC,MAAM;2BAUN,YAAY,SAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC;;;MC5BvB,kBAAkB;;;YAL9B,QAAQ,SAAC;gBACR,YAAY,EAAE,CAAC,kBAAkB,CAAC;gBAClC,OAAO,EAAE,CAAC,mBAAmB,EAAE,kBAAkB,CAAC;gBAClD,SAAS,EAAE,CAAC,WAAW,CAAC;aACzB;;;MCOY,SAA0D,SAAQC,WAAe;;;;;;;;;;;;;;IAoB5F,YACS,QAAgC,EACvC,eAA6E,EAC7E,cAA6D;QAE7D,KAAK,CAAC,QAAQ,EAAE,eAAe,EAAE,cAAc,CAAC,CAAC;QAJ1C,aAAQ,GAAR,QAAQ,CAAwB;KAKxC;;;;;;IAOD,EAAE,CAAC,KAAa;QACd,OAAO,KAAK,CAAC,EAAE,CAAC,KAAK,CAAyB,CAAC;KAChD;;;;;;IAOD,IAAI,CAAC,OAA6B;QAChC,OAAO,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KAC5B;;;;;;;IAQD,MAAM,CAAC,KAAa,EAAE,OAA6B;QACjD,OAAO,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;KACrC;;;;;;;IAQD,UAAU,CAAC,KAAa,EAAE,OAA6B;QACrD,OAAO,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;KACzC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAoCD,QAAQ,CAAC,KAAgC,EAAE,UAAuD,EAAE;QAClG,OAAO,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;KACvC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAmCD,UAAU,CAAC,KAAgC,EAAE,UAAuD,EAAE;QACpG,OAAO,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;KACzC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA+CD,KAAK,CAAC,QAAkC,EAAE,EAAE,UAAuD,EAAE;QACnG,OAAO,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;KACpC;;;;;;;IAQD,WAAW;QACT,OAAO,KAAK,CAAC,WAAW,EAA+B,CAAC;KACzD;;;;;IAMD,aAAa,CAAC,YAAgD;QAC5D,OAAO,KAAK,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;KAC1C;;;;;IAMD,kBAAkB,CAAC,YAA0D;QAC3E,OAAO,KAAK,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC;KAC/C;;;;;;;;;;;;;;;;;;;;;;IAuBD,SAAS,CAAC,MAA+B,EAAE,OAAgC,EAAE;QAC3E,OAAO,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;KACtC;;;;;;;;;;;;;;;;;;;;;;;;;;;IA4BD,QAAQ,CAAsD,SAAY,EAAE,WAAe;QACzF,OAAO,KAAK,CAAC,QAAQ,CAAC,SAAS,EAAE,WAAW,CAAgB,CAAC;KAC9D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA8BD,QAAQ,CAAsD,SAAY,EAAE,WAAe;QACzF,OAAO,KAAK,CAAC,QAAQ,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;KAC/C;;;MC9SU,WAAyD,SAAQC,aAAiB;;;;;;;;;;;;;;IAoB7F,YACE,YAAiC,IAAI,EACrC,eAA6E,EAC7E,cAA6D;QAE7D,KAAK,CAAC,SAAS,EAAE,eAAe,EAAE,cAAc,CAAC,CAAC;KACnD;;;;;;;;;;;;;;;;;;;;;;;;IAyBD,QAAQ,CACN,KAA6B,EAC7B,UAKI,EAAE;QAEN,OAAO,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;KACvC;;;;;;;;;;IAWD,UAAU,CACR,KAA6B,EAC7B,UAKI,EAAE;QAEN,OAAO,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;KACzC;;;;;;;;;;;;;;;;;;;IAoBD,KAAK,CACH,YAAiC,IAAI,EACrC,UAGI,EAAE;QAEN,OAAO,KAAK,CAAC,KAAK,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;KACxC;;;;IAKD,GAAG;QACD,OAAO,IAAI,CAAC;KACb;;;;;IAMD,aAAa,CAAC,YAAgD;QAC5D,OAAO,KAAK,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;KAC1C;;;;;IAMD,kBAAkB,CAAC,YAA0D;QAC3E,OAAO,KAAK,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC;KAC/C;;;;;;;;;;;;;;;;;;;;;;IAuBD,SAAS,CAAC,MAA+B,EAAE,OAAgC,EAAE;QAC3E,OAAO,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;KACtC;;;;;;;;;IAUD,QAAQ,CAAgC,SAAY;QAClD,OAAO,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAgB,CAAC;KACjD;;;;;;;;;;IAWD,QAAQ,CAAgC,SAAY;QAClD,OAAO,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;KAClC;;;MCvLU,SAAsE,SAAQC,WAAe;;;;;;;;;;;;;;;IAqBxG,YACS,QAAkD,EACzD,eAA6E,EAC7E,cAA6D;QAE7D,KAAK,CAAC,QAAQ,EAAE,eAAe,EAAE,cAAc,CAAC,CAAC;QAJ1C,aAAQ,GAAR,QAAQ,CAA0C;KAK1D;;;;;;;;;;IAWD,eAAe,CACb,IAAO,EACP,OAA8B;QAE9B,OAAO,KAAK,CAAC,eAAe,CAAC,IAAI,EAAE,OAAO,CAA0B,CAAC;KACtE;;;;;;;;;IAUD,UAAU,CAA+D,IAAO,EAAE,OAA8B;QAC9G,OAAO,KAAK,CAAC,UAAU,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACxC;;;;;;IAOD,aAAa,CAA0B,IAAO;QAC5C,OAAO,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;KAClC;;;;;;;IAQD,UAAU,CAA+D,IAAO,EAAE,OAA8B;QAC9G,OAAO,KAAK,CAAC,UAAU,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACxC;;;;;;;;;;;IAYD,QAAQ,CAA0B,IAAO;QACvC,OAAO,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;KAC7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAoCD,QAAQ,CAAC,KAA2B,EAAE,UAAuD,EAAE;QAC7F,OAAO,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;KACvC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAkCD,UAAU,CAAC,KAAoC,EAAE,UAAuD,EAAE;QACxG,OAAO,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;KACzC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA0DD,KAAK,CAAC,QAA8B,EAAS,EAAE,UAAuD,EAAE;QACtG,OAAO,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;KACpC;;;;;;;;IASD,WAAW;QACT,OAAO,KAAK,CAAC,WAAW,EAA0B,CAAC;KACpD;;;;;;;;;;;IAYD,GAAG,CAA+D,WAAc;QAC9E,OAAO,KAAK,CAAC,GAAG,CAAC,WAAW,CAAiC,CAAC;KAC/D;;;;;IAMD,aAAa,CAAC,YAAgD;QAC5D,OAAO,KAAK,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;KAC1C;;;;;IAMD,kBAAkB,CAAC,YAA0D;QAC3E,OAAO,KAAK,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC;KAC/C;;;;;;;;;;;;;;;;;;;;;;IAuBD,SAAS,CAAC,MAA+B,EAAE,OAAgC,EAAE;QAC3E,OAAO,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;KACtC;;;;;;;;;;;;;;;;;;;;;;;;;;;IA4BD,QAAQ,CAAmD,SAAY,EAAE,WAAe;QACtF,OAAO,KAAK,CAAC,QAAQ,CAAC,SAAS,EAAE,WAAW,CAAgB,CAAC;KAC9D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA8BD,QAAQ,CAAmD,SAAY,EAAE,WAAe;QACtF,OAAO,KAAK,CAAC,QAAQ,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;KAC/C;;;ACzWH;AACA;AACA;;;;;;;;MAQa,UAAW,SAAQC,YAAgB;;;;;;;;;;;;;;;;;IAiB9C,OAAO,GAAG,CAAC,GAAW;QACpB,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAA0D,CAAC;KAChF;;;;;;;;;;;;;;;;;IAkBD,OAAO,GAAG,CAAC,GAAW;QACpB,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAA0D,CAAC;KAChF;;;;;;;;;;;;;;;;IAiBD,OAAO,QAAQ,CAAC,OAAwB;QACtC,OAAO,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAgD,CAAC;KAC/E;;;;;;;;;;;;;;;;IAiBD,OAAO,YAAY,CAAC,OAAwB;QAC1C,OAAO,KAAK,CAAC,YAAY,CAAC,OAAO,CAAgD,CAAC;KACnF;;;;;;;;;;;;;;;;IAiBD,OAAO,KAAK,CAAC,OAAwB;QACnC,OAAO,KAAK,CAAC,KAAK,CAAC,OAAO,CAA6C,CAAC;KACzE;;;;;;;;;;;;;;;;;;;;;IAsBD,OAAO,SAAS,CAAC,SAAiB;QAChC,OAAO,KAAK,CAAC,SAAS,CAAC,SAAS,CAE9B,CAAC;KACJ;;;;;;;;;;;;;;;;;;;;;IAsBD,OAAO,SAAS,CAAC,SAAiB;QAChC,OAAO,KAAK,CAAC,SAAS,CAAC,SAAS,CAE9B,CAAC;KACJ;;;;;;;;;;;;;;;;;;;;;;;;;IA0BD,OAAO,OAAO,CAAC,OAAwB;QACrC,OAAO,KAAK,CAAC,OAAO,CAAC,OAAO,CAE1B,CAAC;KACJ;;;;IAKD,OAAO,aAAa,CAAC,OAAwB;QAC3C,OAAO,IAAI,CAAC;KACb;IAWD,OAAO,OAAO,CAAyB,UAAqD;QAC1F,OAAO,KAAK,CAAC,OAAO,CAAC,UAAU,CAA0B,CAAC;KAC3D;;;;;;;;IASD,OAAO,YAAY,CAAyB,UAA0C;QACpF,OAAO,KAAK,CAAC,YAAY,CAAC,UAAU,CAA+B,CAAC;KACrE;;;;;;IAOD,OAAO,YAAY,CAAC,WAAkC;QACpD,IAAI,EAAE,WAAW,CAAC,KAAK,YAAY,QAAQ,CAAC,EAAE;YAC5C,OAAO,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC;SAC/B;QAED,MAAM,KAAK,GAAW,EAAE,CAAC;QACzB,WAAW,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAU,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAE5D,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YACxB,IAAI,IAAI,YAAY,IAAI,EAAE;gBACxB,OAAO,IAAI,CAAC;aACb;SACF;QAED,OAAO,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC;KAC/B;;;;;;IAOD,OAAO,cAAc,CACnB,SAAiB;QAIjB,OAAO,CAAC,WAAkC;YACxC,MAAM,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC;YAEhC,IAAI,SAAS,GAAG,CAAC,EAAE;gBACjB,OAAO,IAAI,CAAC;aACb;YAED,IAAI,CAAC,KAAK,IAAI,EAAE,KAAK,YAAY,QAAQ,CAAC,EAAE;gBAC1C,OAAO,EAAE,cAAc,EAAE,EAAE,cAAc,EAAE,SAAS,EAAE,YAAY,EAAE,CAAC,EAAE,EAAE,CAAC;aAC3E;YAED,MAAM,KAAK,GAAW,EAAE,CAAC;YACzB,KAAK,CAAC,OAAO,CAAC,CAAC,IAAU,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChD,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;YACzB,IAAI,GAAG,GAAG,SAAS,EAAE;gBACnB,OAAO,EAAE,cAAc,EAAE,EAAE,cAAc,EAAE,SAAS,EAAE,YAAY,EAAE,GAAG,EAAE,EAAE,CAAC;aAC7E;YAED,OAAO,IAAI,CAAC;SACb,CAAC;KACH;;;;;;IAOD,OAAO,cAAc,CACnB,SAAiB;QAIjB,OAAO,CAAC,WAAkC;YACxC,IAAI,EAAE,WAAW,CAAC,KAAK,YAAY,QAAQ,CAAC,EAAE;gBAC5C,OAAO,IAAI,CAAC;aACb;YAED,MAAM,KAAK,GAAW,EAAE,CAAC;YACzB,WAAW,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAU,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC5D,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;YACzB,IAAI,GAAG,GAAG,SAAS,EAAE;gBACnB,OAAO,EAAE,cAAc,EAAE,EAAE,cAAc,EAAE,SAAS,EAAE,YAAY,EAAE,GAAG,EAAE,EAAE,CAAC;aAC7E;YAED,OAAO,IAAI,CAAC;SACb,CAAC;KACH;;;;;;IAOD,OAAO,WAAW,CAChB,OAAe;QAIf,OAAO,CAAC,WAAkC;YACxC,IAAI,EAAE,WAAW,CAAC,KAAK,YAAY,QAAQ,CAAC,EAAE;gBAC5C,OAAO,IAAI,CAAC;aACb;YAED,MAAM,KAAK,GAAW,EAAE,CAAC;YACzB,WAAW,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAU,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC5D,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;gBACxB,IAAI,IAAI,YAAY,IAAI,IAAI,IAAI,CAAC,IAAI,GAAG,OAAO,EAAE;oBAC/C,OAAO,EAAE,WAAW,EAAE,EAAE,YAAY,EAAE,OAAO,EAAE,UAAU,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,CAAC;iBAChF;aACF;YAED,OAAO,IAAI,CAAC;SACb,CAAC;KACH;;;ACrQH,MAAM,GAAG,GAAG,MAAM,EAAE,CAAC;AAkJrB;;;;;;;;;;;;;;MAca,eAAe;;;ACtO5B;;;;ACAA;;;;;;"}